/**
 * Content Discovery Integration Test
 * Generated by Kiro - HauntedAI Platform
 * 
 * This test validates content discovery functionality with real data:
 * 1. Create test rooms with assets
 * 2. Test filtering by agent type
 * 3. Test explore endpoint with pagination
 * 4. Test asset details retrieval
 * 5. Verify all required fields are present
 */

const http = require('http');
const https = require('https');

const API_BASE_URL = process.env.API_URL || 'http://localhost:3001';
const TEST_USER_ID = 'test-user-discovery-' + Date.now();

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function makeRequest(method, path, data = null, token = null) {
  return new Promise((resolve, reject) => {
    const url = new URL(path, API_BASE_URL);
    const headers = {
      'Content-Type': 'application/json',
    };

    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    const options = {
      method,
      headers,
    };

    const client = url.protocol === 'https:' ? https : http;

    const req = client.request(url, options, (res) => {
      let body = '';
      res.on('data', (chunk) => (body += chunk));
      res.on('end', () => {
        try {
          const response = body ? JSON.parse(body) : {};
          resolve({ status: res.statusCode, data: response, headers: res.headers });
        } catch (e) {
          resolve({ status: res.statusCode, data: body, headers: res.headers });
        }
      });
    });

    req.on('error', reject);

    if (data) {
      req.write(JSON.stringify(data));
    }

    req.end();
  });
}

async function testContentDiscovery() {
  log('\nğŸ” HauntedAI - Content Discovery Integration Test ğŸ”\n', 'yellow');
  log('=' .repeat(70), 'yellow');

  const testResults = {
    passed: 0,
    failed: 0,
    tests: [],
  };

  function recordTest(name, passed, details = '') {
    testResults.tests.push({ name, passed, details });
    if (passed) {
      testResults.passed++;
      log(`  âœ“ ${name}`, 'green');
      if (details) log(`    ${details}`, 'cyan');
    } else {
      testResults.failed++;
      log(`  âœ— ${name}`, 'red');
      if (details) log(`    ${details}`, 'red');
    }
  }

  try {
    // Step 1: Health Check
    log('\nğŸ“‹ Step 1: Health Check', 'blue');
    const health = await makeRequest('GET', '/health');
    recordTest('API Health Check', health.status === 200);

    // Step 2: Create test rooms with different agent types
    log('\nğŸ“‹ Step 2: Create Test Rooms with Assets', 'blue');
    const testRooms = [];
    const agentTypes = ['story', 'asset', 'code', 'deploy'];

    for (let i = 0; i < 4; i++) {
      const roomData = {
        userId: TEST_USER_ID,
        inputText: `Test content ${i + 1} for ${agentTypes[i]} agent`,
      };

      const response = await makeRequest('POST', '/api/v1/rooms', roomData);
      if (response.status === 201 || response.status === 200) {
        testRooms.push(response.data);
        log(`  Created room ${i + 1}: ${response.data.id}`, 'cyan');
      }
    }

    recordTest(
      'Create Test Rooms',
      testRooms.length === 4,
      `Created ${testRooms.length} rooms`
    );

    // Step 3: Test Assets Listing (without filter)
    log('\nğŸ“‹ Step 3: Test Assets Listing (No Filter)', 'blue');
    const allAssets = await makeRequest('GET', '/api/v1/assets');

    if (allAssets.status === 200) {
      const assets = allAssets.data;
      recordTest(
        'List All Assets',
        Array.isArray(assets),
        `Retrieved ${assets.length} assets`
      );

      // Verify each asset has required fields
      if (assets.length > 0) {
        const firstAsset = assets[0];
        const hasRequiredFields =
          firstAsset.id &&
          firstAsset.cid &&
          firstAsset.agentType &&
          firstAsset.fileType &&
          typeof firstAsset.fileSize === 'number' &&
          firstAsset.createdAt;

        recordTest(
          'Assets Have Required Fields',
          hasRequiredFields,
          `Fields: id, cid, agentType, fileType, fileSize, createdAt`
        );

        // Verify CID format
        const validCID = /^bafy[a-z0-9]+$/.test(firstAsset.cid);
        recordTest(
          'CID Format Validation',
          validCID,
          `CID: ${firstAsset.cid.substring(0, 20)}...`
        );
      }
    } else {
      recordTest('List All Assets', false, `Status: ${allAssets.status}`);
    }

    // Step 4: Test Filtering by Agent Type
    log('\nğŸ“‹ Step 4: Test Filtering by Agent Type', 'blue');
    for (const agentType of agentTypes) {
      const filtered = await makeRequest('GET', `/api/v1/assets?agentType=${agentType}`);

      if (filtered.status === 200) {
        const assets = filtered.data;
        const allMatch = assets.every((asset) => asset.agentType === agentType);

        recordTest(
          `Filter by ${agentType}`,
          allMatch,
          `Found ${assets.length} ${agentType} assets`
        );
      } else {
        recordTest(`Filter by ${agentType}`, false, `Status: ${filtered.status}`);
      }
    }

    // Step 5: Test Filtering by Room ID
    log('\nğŸ“‹ Step 5: Test Filtering by Room ID', 'blue');
    if (testRooms.length > 0) {
      const roomId = testRooms[0].id;
      const roomAssets = await makeRequest('GET', `/api/v1/assets?roomId=${roomId}`);

      if (roomAssets.status === 200) {
        const assets = roomAssets.data;
        const allMatch = assets.every((asset) => asset.roomId === roomId);

        recordTest(
          'Filter by Room ID',
          allMatch,
          `Found ${assets.length} assets for room ${roomId.substring(0, 8)}...`
        );
      } else {
        recordTest('Filter by Room ID', false, `Status: ${roomAssets.status}`);
      }
    }

    // Step 6: Test Pagination
    log('\nğŸ“‹ Step 6: Test Pagination', 'blue');
    const page1 = await makeRequest('GET', '/api/v1/assets?limit=2&offset=0');
    const page2 = await makeRequest('GET', '/api/v1/assets?limit=2&offset=2');

    if (page1.status === 200 && page2.status === 200) {
      const page1Assets = page1.data;
      const page2Assets = page2.data;

      recordTest(
        'Pagination Limit',
        page1Assets.length <= 2,
        `Page 1: ${page1Assets.length} assets`
      );

      // Verify different results
      const differentPages =
        page1Assets.length === 0 ||
        page2Assets.length === 0 ||
        page1Assets[0].id !== page2Assets[0]?.id;

      recordTest(
        'Pagination Offset',
        differentPages,
        `Page 2: ${page2Assets.length} assets`
      );
    } else {
      recordTest('Pagination', false, 'Failed to retrieve paginated results');
    }

    // Step 7: Test Explore Endpoint (Public Discovery)
    log('\nğŸ“‹ Step 7: Test Explore Endpoint (Public Discovery)', 'blue');
    const explore = await makeRequest('GET', '/api/v1/assets/explore?page=1&pageSize=10');

    if (explore.status === 200) {
      const result = explore.data;
      const hasData = Array.isArray(result.data);
      const hasPagination =
        result.pagination &&
        typeof result.pagination.page === 'number' &&
        typeof result.pagination.pageSize === 'number' &&
        typeof result.pagination.total === 'number';

      recordTest(
        'Explore Endpoint Structure',
        hasData && hasPagination,
        `Data: ${result.data?.length || 0} items, Total: ${result.pagination?.total || 0}`
      );

      // Test explore with agent type filter
      const exploreFiltered = await makeRequest(
        'GET',
        '/api/v1/assets/explore?agentType=story&page=1&pageSize=5'
      );

      if (exploreFiltered.status === 200) {
        const filtered = exploreFiltered.data;
        const allStory = filtered.data.every((asset) => asset.agentType === 'story');

        recordTest(
          'Explore with Filter',
          allStory,
          `Found ${filtered.data.length} story assets`
        );
      }
    } else {
      recordTest('Explore Endpoint', false, `Status: ${explore.status}`);
    }

    // Step 8: Test Asset Details Retrieval
    log('\nğŸ“‹ Step 8: Test Asset Details Retrieval', 'blue');
    const allAssetsForDetail = await makeRequest('GET', '/api/v1/assets');

    if (allAssetsForDetail.status === 200 && allAssetsForDetail.data.length > 0) {
      const assetId = allAssetsForDetail.data[0].id;
      const assetDetails = await makeRequest('GET', `/api/v1/assets/${assetId}`);

      if (assetDetails.status === 200) {
        const asset = assetDetails.data;

        // Verify all required fields for content modal
        const hasAllFields =
          asset.id &&
          asset.cid &&
          asset.agentType &&
          asset.fileType &&
          typeof asset.fileSize === 'number' &&
          asset.metadata &&
          asset.createdAt;

        recordTest(
          'Asset Details Completeness',
          hasAllFields,
          'All required fields present'
        );

        // Verify metadata structure
        const hasMetadata = typeof asset.metadata === 'object';
        recordTest(
          'Asset Metadata Present',
          hasMetadata,
          `Metadata keys: ${Object.keys(asset.metadata || {}).join(', ')}`
        );

        // Verify timestamp is valid
        const validTimestamp = new Date(asset.createdAt).getTime() > 0;
        recordTest(
          'Asset Timestamp Valid',
          validTimestamp,
          `Created: ${asset.createdAt}`
        );

        // Verify file size is positive
        const validFileSize = asset.fileSize > 0;
        recordTest(
          'Asset File Size Valid',
          validFileSize,
          `Size: ${asset.fileSize} bytes`
        );

        // Verify CID format
        const validCID = /^bafy[a-z0-9]+$/.test(asset.cid);
        recordTest(
          'Asset CID Format Valid',
          validCID,
          `CID: ${asset.cid.substring(0, 30)}...`
        );
      } else {
        recordTest('Asset Details Retrieval', false, `Status: ${assetDetails.status}`);
      }
    } else {
      log('  âš  No assets available for detail testing', 'yellow');
    }

    // Step 9: Test Error Handling
    log('\nğŸ“‹ Step 9: Test Error Handling', 'blue');
    const invalidAsset = await makeRequest('GET', '/api/v1/assets/invalid-id-12345');
    recordTest(
      'Invalid Asset ID Handling',
      invalidAsset.status === 404 || invalidAsset.status === 400,
      `Status: ${invalidAsset.status}`
    );

    // Summary
    log('\n' + '='.repeat(70), 'yellow');
    log('ğŸ“Š Test Results Summary', 'magenta');
    log('=' .repeat(70), 'yellow');
    log(`\n  Total Tests: ${testResults.passed + testResults.failed}`, 'blue');
    log(`  âœ“ Passed: ${testResults.passed}`, 'green');
    log(`  âœ— Failed: ${testResults.failed}`, testResults.failed > 0 ? 'red' : 'green');
    log(
      `  Success Rate: ${((testResults.passed / (testResults.passed + testResults.failed)) * 100).toFixed(1)}%`,
      testResults.failed === 0 ? 'green' : 'yellow'
    );

    if (testResults.failed === 0) {
      log('\nğŸ‰ All Content Discovery Tests Passed! ğŸ‰', 'green');
    } else {
      log('\nâš ï¸  Some Tests Failed - Review Details Above', 'yellow');
    }

    log('\n' + '='.repeat(70), 'yellow');

    return {
      success: testResults.failed === 0,
      passed: testResults.passed,
      failed: testResults.failed,
      tests: testResults.tests,
    };
  } catch (error) {
    log('\nâŒ Test Execution Failed!', 'red');
    log(`Error: ${error.message}`, 'red');
    if (error.stack) {
      log(error.stack, 'red');
    }
    return {
      success: false,
      error: error.message,
      passed: testResults.passed,
      failed: testResults.failed + 1,
    };
  }
}

// Run the test
if (require.main === module) {
  testContentDiscovery()
    .then((result) => {
      process.exit(result.success ? 0 : 1);
    })
    .catch((error) => {
      log(`\nâŒ Unexpected error: ${error.message}`, 'red');
      process.exit(1);
    });
}

module.exports = { testContentDiscovery };
