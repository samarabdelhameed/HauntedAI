#!/usr/bin/env node
/**
 * SSE Integration Test Script
 * Generated by Kiro
 * 
 * This script tests the SSE implementation by:
 * 1. Creating a test room
 * 2. Connecting to SSE endpoint
 * 3. Publishing test logs
 * 4. Verifying logs are received
 * 
 * Requirements: 5.1, 5.2
 */

const http = require('http');
const Redis = require('ioredis');

// Configuration
const API_URL = process.env.API_URL || 'http://localhost:3001';
const REDIS_URL = process.env.REDIS_URL || 'redis://localhost:6379';
const JWT_TOKEN = process.env.TEST_JWT_TOKEN || 'test-token';

// Test data
const TEST_ROOM_ID = 'test-room-' + Date.now();
const TEST_LOGS = [
  {
    timestamp: new Date().toISOString(),
    agentType: 'story',
    level: 'info',
    message: 'Starting story generation',
    metadata: { test: true }
  },
  {
    timestamp: new Date().toISOString(),
    agentType: 'story',
    level: 'success',
    message: 'Story generation completed',
    metadata: { test: true }
  },
  {
    timestamp: new Date().toISOString(),
    agentType: 'asset',
    level: 'info',
    message: 'Starting image generation',
    metadata: { test: true }
  }
];

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`âœ… ${message}`, 'green');
}

function logError(message) {
  log(`âŒ ${message}`, 'red');
}

function logInfo(message) {
  log(`â„¹ï¸  ${message}`, 'blue');
}

function logWarning(message) {
  log(`âš ï¸  ${message}`, 'yellow');
}

// Test SSE connection
async function testSSEConnection() {
  return new Promise((resolve, reject) => {
    logInfo('Testing SSE connection...');
    
    const receivedLogs = [];
    let connected = false;
    let heartbeatReceived = false;

    const options = {
      hostname: 'localhost',
      port: 3001,
      path: `/api/v1/rooms/${TEST_ROOM_ID}/logs`,
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${JWT_TOKEN}`,
        'Accept': 'text/event-stream'
      }
    };

    const req = http.request(options, (res) => {
      if (res.statusCode !== 200) {
        logError(`SSE connection failed with status ${res.statusCode}`);
        reject(new Error(`HTTP ${res.statusCode}`));
        return;
      }

      logSuccess('SSE connection established');

      let buffer = '';

      res.on('data', (chunk) => {
        buffer += chunk.toString();
        
        // Process complete SSE messages
        const lines = buffer.split('\n\n');
        buffer = lines.pop(); // Keep incomplete message in buffer

        lines.forEach(message => {
          if (!message.trim()) return;

          const eventMatch = message.match(/event: (\w+)/);
          const dataMatch = message.match(/data: (.+)/);

          if (eventMatch && dataMatch) {
            const event = eventMatch[1];
            const data = JSON.parse(dataMatch[1]);

            switch (event) {
              case 'connected':
                connected = true;
                logSuccess(`Connected to room: ${data.roomId}`);
                break;

              case 'log':
                receivedLogs.push(data);
                log(`ðŸ“ [${data.agentType}] ${data.level}: ${data.message}`, 'cyan');
                break;

              case 'heartbeat':
                if (!heartbeatReceived) {
                  heartbeatReceived = true;
                  logInfo(`Heartbeat received at ${data.timestamp}`);
                }
                break;
            }
          }
        });
      });

      res.on('end', () => {
        logInfo('SSE connection closed');
        resolve({
          connected,
          heartbeatReceived,
          receivedLogs,
          logsCount: receivedLogs.length
        });
      });
    });

    req.on('error', (error) => {
      logError(`SSE connection error: ${error.message}`);
      reject(error);
    });

    req.end();

    // Close connection after 5 seconds
    setTimeout(() => {
      req.destroy();
    }, 5000);
  });
}

// Publish test logs via Redis
async function publishTestLogs() {
  logInfo('Publishing test logs via Redis...');
  
  const redis = new Redis(REDIS_URL);
  const channel = `room:${TEST_ROOM_ID}:logs`;

  for (const log of TEST_LOGS) {
    await redis.publish(channel, JSON.stringify(log));
    logInfo(`Published: ${log.message}`);
    await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms between logs
  }

  await redis.quit();
  logSuccess(`Published ${TEST_LOGS.length} test logs`);
}

// Main test function
async function runTests() {
  log('\nðŸ§ª SSE Integration Test', 'yellow');
  log('='.repeat(50), 'yellow');
  log(`Room ID: ${TEST_ROOM_ID}`, 'cyan');
  log(`API URL: ${API_URL}`, 'cyan');
  log(`Redis URL: ${REDIS_URL}`, 'cyan');
  log('='.repeat(50) + '\n', 'yellow');

  try {
    // Test 1: Check Redis connection
    logInfo('Test 1: Checking Redis connection...');
    const redis = new Redis(REDIS_URL);
    await redis.ping();
    await redis.quit();
    logSuccess('Redis connection OK');

    // Test 2: Start SSE connection in background
    logInfo('\nTest 2: Starting SSE connection...');
    const ssePromise = testSSEConnection();

    // Wait a bit for SSE to connect
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Test 3: Publish logs
    logInfo('\nTest 3: Publishing test logs...');
    await publishTestLogs();

    // Test 4: Wait for SSE to receive logs
    logInfo('\nTest 4: Waiting for logs to be received...');
    const result = await ssePromise;

    // Test 5: Verify results
    log('\nðŸ“Š Test Results', 'yellow');
    log('='.repeat(50), 'yellow');
    log(`Connected: ${result.connected ? 'âœ…' : 'âŒ'}`, result.connected ? 'green' : 'red');
    log(`Heartbeat: ${result.heartbeatReceived ? 'âœ…' : 'âŒ'}`, result.heartbeatReceived ? 'green' : 'red');
    log(`Logs received: ${result.logsCount}/${TEST_LOGS.length}`, result.logsCount === TEST_LOGS.length ? 'green' : 'yellow');
    log('='.repeat(50) + '\n', 'yellow');

    if (result.connected && result.logsCount > 0) {
      logSuccess('âœ¨ All tests passed! SSE implementation is working correctly.');
      process.exit(0);
    } else {
      logWarning('âš ï¸  Some tests failed. Check the output above.');
      process.exit(1);
    }

  } catch (error) {
    logError(`Test failed: ${error.message}`);
    console.error(error);
    process.exit(1);
  }
}

// Run tests
if (require.main === module) {
  runTests().catch(error => {
    logError(`Fatal error: ${error.message}`);
    process.exit(1);
  });
}

module.exports = { runTests };
