// Generated by Kiro - Property-Based Tests
import { Test, TestingModule } from '@nestjs/testing';
import { JwtService } from '@nestjs/jwt';
import { ethers } from 'ethers';
import * as fc from 'fast-check';

import { AuthService } from './auth.service';
import { PrismaService } from '../../prisma/prisma.service';

describe('Authentication Property-Based Tests', () => {
  let service: AuthService;
  let prismaService: PrismaService;
  let jwtService: JwtService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: PrismaService,
          useValue: {
            user: {
              findUnique: jest.fn(),
              create: jest.fn(),
            },
          },
        },
        {
          provide: JwtService,
          useValue: {
            sign: jest.fn().mockReturnValue('mock-jwt-token'),
          },
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    prismaService = module.get<PrismaService>(PrismaService);
    jwtService = module.get<JwtService>(JwtService);
  });

  // Feature: haunted-ai, Property 39: Wallet connection triggers signature request
  // Validates: Requirements 11.1
  describe('Property 39: Wallet connection triggers signature request', () => {
    it('should verify that any valid wallet can create a signature', async () => {
      await fc.assert(
        fc.asyncProperty(fc.integer({ min: 0, max: 100 }), async (_seed) => {
          // Generate random wallet
          const wallet = ethers.Wallet.createRandom();
          const message = 'Test message';

          // Sign message
          const signature = await wallet.signMessage(message);

          // Verify signature
          const isValid = await service.verifySignature(wallet.address, message, signature);

          // Property: Valid signatures should always verify correctly
          expect(isValid).toBe(true);
        }),
        { numRuns: 100 }
      );
    });

    it('should reject signatures from different wallets', async () => {
      await fc.assert(
        fc.asyncProperty(fc.integer({ min: 0, max: 100 }), async (_seed) => {
          // Generate two different wallets
          const wallet1 = ethers.Wallet.createRandom();
          const wallet2 = ethers.Wallet.createRandom();
          const message = 'Test message';

          // Wallet1 signs the message
          const signature = await wallet1.signMessage(message);

          // Try to verify with wallet2's address
          const isValid = await service.verifySignature(wallet2.address, message, signature);

          // Property: Signature from wallet1 should not verify for wallet2
          expect(isValid).toBe(false);
        }),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 40: Valid signature issues JWT
  // Validates: Requirements 11.2
  describe('Property 40: Valid signature issues JWT', () => {
    it('should issue JWT token for any valid signature', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.string({ minLength: 10, maxLength: 100 }),
          async (username) => {
            const wallet = ethers.Wallet.createRandom();
            const message = 'Sign to authenticate';
            const signature = await wallet.signMessage(message);

            // Mock signature verification
            jest.spyOn(service, 'verifySignature').mockResolvedValue(true);

            // Mock user creation
            const mockUser = {
              id: `user-${Date.now()}`,
              did: `did:ethr:${wallet.address.toLowerCase()}`,
              username: username.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 20),
              walletAddress: wallet.address.toLowerCase(),
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(null);
            jest.spyOn(prismaService.user, 'create').mockResolvedValue(mockUser);

            const result = await service.login({
              walletAddress: wallet.address,
              message,
              signature,
            });

            // Property: Valid signature should always result in JWT token
            expect(result).toHaveProperty('accessToken');
            expect(result.accessToken).toBe('mock-jwt-token');
            expect(result.user.walletAddress).toBe(wallet.address.toLowerCase());
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should generate unique user IDs for different wallets', async () => {
      const userIds = new Set<string>();

      await fc.assert(
        fc.asyncProperty(fc.integer({ min: 0, max: 100 }), async (_seed) => {
          const wallet = ethers.Wallet.createRandom();
          const message = 'Sign to authenticate';
          const signature = await wallet.signMessage(message);

          jest.spyOn(service, 'verifySignature').mockResolvedValue(true);

          const userId = `user-${wallet.address.toLowerCase()}`;
          const mockUser = {
            id: userId,
            did: `did:ethr:${wallet.address.toLowerCase()}`,
            username: `user_${wallet.address.slice(2, 8)}`,
            walletAddress: wallet.address.toLowerCase(),
            createdAt: new Date(),
            updatedAt: new Date(),
          };

          jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(null);
          jest.spyOn(prismaService.user, 'create').mockResolvedValue(mockUser);

          const result = await service.login({
            walletAddress: wallet.address,
            message,
            signature,
          });

          // Property: Each wallet should get a unique user ID
          expect(userIds.has(result.user.id)).toBe(false);
          userIds.add(result.user.id);
        }),
        { numRuns: 50 }
      );
    });
  });

  // Feature: haunted-ai, Property 41: JWT storage and usage
  // Validates: Requirements 11.3
  describe('Property 41: JWT storage and usage', () => {
    it('should include user information in JWT payload', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            username: fc.string({ minLength: 5, maxLength: 20 }),
            did: fc.string({ minLength: 10, maxLength: 50 }),
          }),
          async (userData) => {
            const wallet = ethers.Wallet.createRandom();
            const message = 'Sign to authenticate';
            const signature = await wallet.signMessage(message);

            jest.spyOn(service, 'verifySignature').mockResolvedValue(true);

            const mockUser = {
              id: `user-${Date.now()}`,
              did: userData.did,
              username: userData.username,
              walletAddress: wallet.address.toLowerCase(),
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(null);
            jest.spyOn(prismaService.user, 'create').mockResolvedValue(mockUser);

            // Mock JWT to return payload
            jest.spyOn(jwtService, 'sign').mockImplementation((payload: any) => {
              return JSON.stringify(payload);
            });

            const result = await service.login({
              walletAddress: wallet.address,
              message,
              signature,
            });

            // Property: JWT should contain user information
            const tokenPayload = JSON.parse(result.accessToken);
            expect(tokenPayload).toHaveProperty('sub');
            expect(tokenPayload).toHaveProperty('did');
            expect(tokenPayload).toHaveProperty('walletAddress');
            expect(tokenPayload.did).toBe(userData.did);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
