// Generated by Kiro - Property-Based Tests
import { Test, TestingModule } from '@nestjs/testing';
import { AgentType } from '@prisma/client';
import * as fc from 'fast-check';

import { PrismaService } from '../../prisma/prisma.service';

import { AssetsService } from './assets.service';

describe('Content Discovery Property-Based Tests', () => {
  let service: AssetsService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AssetsService,
        {
          provide: PrismaService,
          useValue: {
            asset: {
              findMany: jest.fn(),
              findUnique: jest.fn(),
              count: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<AssetsService>(AssetsService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Feature: haunted-ai, Property 35: Filter correctness
  // Validates: Requirements 10.2
  describe('Property 35: Filter correctness', () => {
    it('should return only assets matching the specified agent type filter', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
          fc.array(
            fc.record({
              id: fc.string({ minLength: 10, maxLength: 50 }),
              roomId: fc.string({ minLength: 10, maxLength: 50 }),
              agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
              cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
              fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
              fileSize: fc.integer({ min: 100, max: 10000000 }),
              metadata: fc.record({
                description: fc.string({ minLength: 10, maxLength: 100 }),
              }),
              createdAt: fc.date(),
            }),
            { minLength: 5, maxLength: 20 }
          ),
          async (filterType, allAssets) => {
            jest.clearAllMocks();

            // Filter assets to match the filter type
            const filteredAssets = allAssets.filter((asset) => asset.agentType === filterType);

            jest.spyOn(prismaService.asset, 'findMany').mockResolvedValue(filteredAssets as any);

            const result = await service.findAll({ agentType: filterType });

            // Property: All returned assets should have matching agent_type
            for (const asset of result) {
              expect(asset.agentType).toBe(filterType);
            }

            // Verify the filter was applied correctly
            expect(result.length).toBe(filteredAssets.length);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should return all assets when no filter is applied', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(
            fc.record({
              id: fc.string({ minLength: 10, maxLength: 50 }),
              roomId: fc.string({ minLength: 10, maxLength: 50 }),
              agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
              cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
              fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
              fileSize: fc.integer({ min: 100, max: 10000000 }),
              metadata: fc.record({
                description: fc.string({ minLength: 10, maxLength: 100 }),
              }),
              createdAt: fc.date(),
            }),
            { minLength: 1, maxLength: 20 }
          ),
          async (allAssets) => {
            jest.clearAllMocks();

            jest.spyOn(prismaService.asset, 'findMany').mockResolvedValue(allAssets as any);

            const result = await service.findAll({});

            // Property: Without filter, all assets should be returned
            expect(result.length).toBe(allAssets.length);

            // Verify all agent types are present if they exist in the data
            const returnedTypes = new Set(result.map((a) => a.agentType));
            const originalTypes = new Set(allAssets.map((a) => a.agentType));
            expect(returnedTypes).toEqual(originalTypes);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should filter by roomId correctly', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.string({ minLength: 10, maxLength: 50 }),
          fc.array(
            fc.record({
              id: fc.string({ minLength: 10, maxLength: 50 }),
              roomId: fc.string({ minLength: 10, maxLength: 50 }),
              agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
              cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
              fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
              fileSize: fc.integer({ min: 100, max: 10000000 }),
              metadata: fc.record({
                description: fc.string({ minLength: 10, maxLength: 100 }),
              }),
              createdAt: fc.date(),
            }),
            { minLength: 5, maxLength: 20 }
          ),
          async (targetRoomId, allAssets) => {
            jest.clearAllMocks();

            // Filter assets to match the room ID
            const filteredAssets = allAssets.filter((asset) => asset.roomId === targetRoomId);

            jest.spyOn(prismaService.asset, 'findMany').mockResolvedValue(filteredAssets as any);

            const result = await service.findAll({ roomId: targetRoomId });

            // Property: All returned assets should belong to the specified room
            for (const asset of result) {
              expect(asset.roomId).toBe(targetRoomId);
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should apply pagination limits correctly', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.integer({ min: 1, max: 50 }),
          fc.array(
            fc.record({
              id: fc.string({ minLength: 10, maxLength: 50 }),
              roomId: fc.string({ minLength: 10, maxLength: 50 }),
              agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
              cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
              fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
              fileSize: fc.integer({ min: 100, max: 10000000 }),
              metadata: fc.record({
                description: fc.string({ minLength: 10, maxLength: 100 }),
              }),
              createdAt: fc.date(),
            }),
            { minLength: 10, maxLength: 100 }
          ),
          async (limit, allAssets) => {
            jest.clearAllMocks();

            // Simulate pagination by taking only 'limit' items
            const paginatedAssets = allAssets.slice(0, limit);

            jest.spyOn(prismaService.asset, 'findMany').mockResolvedValue(paginatedAssets as any);

            const result = await service.findAll({ limit });

            // Property: Result should not exceed the specified limit
            expect(result.length).toBeLessThanOrEqual(limit);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 36: Content modal completeness
  // Validates: Requirements 10.3
  describe('Property 36: Content modal completeness', () => {
    it('should return complete asset details with all required fields', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            id: fc.string({ minLength: 10, maxLength: 50 }),
            roomId: fc.string({ minLength: 10, maxLength: 50 }),
            agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
            cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
            fileSize: fc.integer({ min: 100, max: 10000000 }),
            metadata: fc.record({
              description: fc.string({ minLength: 10, maxLength: 100 }),
              title: fc.string({ minLength: 5, maxLength: 50 }),
              author: fc.string({ minLength: 3, maxLength: 30 }),
            }),
            createdAt: fc.date(),
          }),
          async (assetData) => {
            jest.clearAllMocks();

            const mockAsset = {
              ...assetData,
              room: {
                id: assetData.roomId,
                ownerId: 'user-123',
                status: 'done',
                inputText: 'Test input',
                createdAt: new Date(),
                updatedAt: new Date(),
              },
            };

            jest.spyOn(prismaService.asset, 'findUnique').mockResolvedValue(mockAsset as any);

            const result = await service.findOne(assetData.id);

            // Property: Result should contain all required fields
            expect(result).toBeDefined();
            expect(result.id).toBe(assetData.id);
            expect(result.cid).toBe(assetData.cid);
            expect(result.agentType).toBe(assetData.agentType);
            expect(result.fileType).toBe(assetData.fileType);
            expect(result.fileSize).toBe(assetData.fileSize);
            expect(result.metadata).toBeDefined();
            expect(result.createdAt).toBeInstanceOf(Date);

            // Property: CID should be present and valid format
            expect(result.cid).toMatch(/^bafy[a-z0-9]+$/);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should include metadata in asset details', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            id: fc.string({ minLength: 10, maxLength: 50 }),
            roomId: fc.string({ minLength: 10, maxLength: 50 }),
            agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
            cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
            fileSize: fc.integer({ min: 100, max: 10000000 }),
            metadata: fc.record({
              description: fc.string({ minLength: 10, maxLength: 100 }),
              tags: fc.array(fc.string({ minLength: 3, maxLength: 20 }), { minLength: 1, maxLength: 5 }),
              customField: fc.string({ minLength: 5, maxLength: 50 }),
            }),
            createdAt: fc.date(),
          }),
          async (assetData) => {
            jest.clearAllMocks();

            const mockAsset = {
              ...assetData,
              room: {
                id: assetData.roomId,
                ownerId: 'user-123',
                status: 'done',
                inputText: 'Test input',
                createdAt: new Date(),
                updatedAt: new Date(),
              },
            };

            jest.spyOn(prismaService.asset, 'findUnique').mockResolvedValue(mockAsset as any);

            const result = await service.findOne(assetData.id);

            // Property: Metadata should be preserved exactly as stored
            expect(result.metadata).toEqual(assetData.metadata);
            const metadata = result.metadata as any;
            expect(metadata.description).toBe(assetData.metadata.description);
            expect(metadata.tags).toEqual(assetData.metadata.tags);
            expect(metadata.customField).toBe(assetData.metadata.customField);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should include timestamp information in asset details', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            id: fc.string({ minLength: 10, maxLength: 50 }),
            roomId: fc.string({ minLength: 10, maxLength: 50 }),
            agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
            cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
            fileSize: fc.integer({ min: 100, max: 10000000 }),
            metadata: fc.record({
              description: fc.string({ minLength: 10, maxLength: 100 }),
            }),
            createdAt: fc.date({ min: new Date('2020-01-01'), max: new Date() }),
          }),
          async (assetData) => {
            jest.clearAllMocks();

            // Ensure createdAt is a valid date
            const validCreatedAt = isNaN(assetData.createdAt.getTime()) 
              ? new Date() 
              : assetData.createdAt;

            const mockAsset = {
              ...assetData,
              createdAt: validCreatedAt,
              room: {
                id: assetData.roomId,
                ownerId: 'user-123',
                status: 'done',
                inputText: 'Test input',
                createdAt: new Date(),
                updatedAt: new Date(),
              },
            };

            jest.spyOn(prismaService.asset, 'findUnique').mockResolvedValue(mockAsset as any);

            const result = await service.findOne(assetData.id);

            // Property: Timestamp should be present and valid
            expect(result.createdAt).toBeInstanceOf(Date);
            expect(isNaN(result.createdAt.getTime())).toBe(false);
            expect(result.createdAt.getTime()).toBeLessThanOrEqual(Date.now());
            expect(result.createdAt.getTime()).toBeGreaterThanOrEqual(new Date('2020-01-01').getTime());
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should return assets with valid CID format for all agent types', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
          fc.record({
            id: fc.string({ minLength: 10, maxLength: 50 }),
            roomId: fc.string({ minLength: 10, maxLength: 50 }),
            cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
            fileSize: fc.integer({ min: 100, max: 10000000 }),
            metadata: fc.record({
              description: fc.string({ minLength: 10, maxLength: 100 }),
            }),
            createdAt: fc.date(),
          }),
          async (agentType, assetData) => {
            jest.clearAllMocks();

            const mockAsset = {
              ...assetData,
              agentType,
              room: {
                id: assetData.roomId,
                ownerId: 'user-123',
                status: 'done',
                inputText: 'Test input',
                createdAt: new Date(),
                updatedAt: new Date(),
              },
            };

            jest.spyOn(prismaService.asset, 'findUnique').mockResolvedValue(mockAsset as any);

            const result = await service.findOne(assetData.id);

            // Property: CID should always be in valid IPFS format
            expect(result.cid).toMatch(/^bafy[a-z0-9]+$/);
            expect(result.cid.length).toBeGreaterThan(50);
            expect(result.agentType).toBe(agentType);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should include file size and type information', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            id: fc.string({ minLength: 10, maxLength: 50 }),
            roomId: fc.string({ minLength: 10, maxLength: 50 }),
            agentType: fc.constantFrom(AgentType.story, AgentType.asset, AgentType.code, AgentType.deploy),
            cid: fc.string({ minLength: 59, maxLength: 59 }).map((s) => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
            fileSize: fc.integer({ min: 100, max: 10000000 }),
            metadata: fc.record({
              description: fc.string({ minLength: 10, maxLength: 100 }),
            }),
            createdAt: fc.date(),
          }),
          async (assetData) => {
            jest.clearAllMocks();

            const mockAsset = {
              ...assetData,
              room: {
                id: assetData.roomId,
                ownerId: 'user-123',
                status: 'done',
                inputText: 'Test input',
                createdAt: new Date(),
                updatedAt: new Date(),
              },
            };

            jest.spyOn(prismaService.asset, 'findUnique').mockResolvedValue(mockAsset as any);

            const result = await service.findOne(assetData.id);

            // Property: File size should be a positive integer
            expect(result.fileSize).toBeGreaterThan(0);
            expect(Number.isInteger(result.fileSize)).toBe(true);

            // Property: File type should be a valid MIME type
            expect(result.fileType).toMatch(/^[a-z]+\/[a-z+]+$/);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
