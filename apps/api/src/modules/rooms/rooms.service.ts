// Generated by Kiro
import { Injectable, NotFoundException, Inject, forwardRef } from '@nestjs/common';

import { PrismaService } from '../../prisma/prisma.service';

import { CreateRoomDto } from './dto/create-room.dto';
import { RedisService } from './redis.service';
import { AgentLog } from './types/agent-log.types';

@Injectable()
export class RoomsService {
  constructor(
    private prisma: PrismaService,
    @Inject(forwardRef(() => RedisService))
    private redisService: RedisService,
  ) {}

  /**
   * Create a new room
   * Requirements: 8.1, 8.2
   */
  async create(createRoomDto: CreateRoomDto & { userId: string }) {
    // Verify user exists
    const user = await this.prisma.user.findUnique({
      where: { id: createRoomDto.userId },
    });

    if (!user) {
      throw new Error('User not found');
    }

    const room = await this.prisma.room.create({
      data: {
        ownerId: createRoomDto.userId,
        inputText: createRoomDto.inputText,
        status: 'idle',
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            did: true,
          },
        },
      },
    });

    return room;
  }

  /**
   * Get room by ID
   * Requirements: 8.3
   */
  async findOne(id: string) {
    const room = await this.prisma.room.findUnique({
      where: { id },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            did: true,
          },
        },
        assets: {
          orderBy: {
            createdAt: 'asc',
          },
        },
      },
    });

    if (!room) {
      throw new NotFoundException(`Room with ID ${id} not found`);
    }

    return room;
  }

  /**
   * Get all rooms for a user
   * Requirements: 8.3
   */
  async findByUser(userId: string) {
    const rooms = await this.prisma.room.findMany({
      where: { ownerId: userId },
      include: {
        assets: {
          select: {
            id: true,
            agentType: true,
            cid: true,
            createdAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return rooms;
  }

  /**
   * Start agent workflow for a room
   * Requirements: 8.3
   */
  async startWorkflow(id: string) {
    // Check if room exists
    const room = await this.prisma.room.findUnique({
      where: { id },
    });

    if (!room) {
      throw new NotFoundException(`Room with ID ${id} not found`);
    }

    // Update room status to running
    const updatedRoom = await this.prisma.room.update({
      where: { id },
      data: {
        status: 'running',
        updatedAt: new Date(),
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            did: true,
          },
        },
      },
    });

    // Trigger mock workflow (simulates agent execution)
    this.simulateWorkflow(id, room.inputText).catch((error) => {
      console.error('Workflow simulation error:', error);
    });

    return {
      ...updatedRoom,
      message: 'Workflow started successfully',
    };
  }

  /**
   * Update room status
   * Requirements: 8.4, 8.5
   */
  async updateStatus(id: string, status: 'idle' | 'running' | 'done' | 'error', errorMessage?: string) {
    const room = await this.prisma.room.findUnique({
      where: { id },
    });

    if (!room) {
      throw new NotFoundException(`Room with ID ${id} not found`);
    }

    const updatedRoom = await this.prisma.room.update({
      where: { id },
      data: {
        status,
        updatedAt: new Date(),
      },
    });

    return updatedRoom;
  }

  /**
   * Simulate workflow execution (mock implementation)
   */
  private async simulateWorkflow(roomId: string, inputText: string): Promise<void> {
    try {
      // Story Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'story', 'info', 'Generating spooky story from your input...');
      await this.sleep(3000);
      
      // Generate rich story content based on user input
      const storyContent = this.generateStoryFromInput(inputText);
      
      // Create story asset with content in metadata
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'story',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'text/plain',
          metadata: JSON.stringify({
            content: storyContent,
            wordCount: storyContent.split(/\s+/).length,
            theme: 'haunted',
          }),
        },
      });
      
      await this.emitLog(roomId, 'story', 'success', 'Story generated successfully!', {
        length: storyContent.length,
        wordCount: storyContent.split(/\s+/).length,
      });

      // Asset Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'asset', 'info', 'Creating haunting image for your story...');
      await this.sleep(4000);
      
      // Create image asset
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'asset',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'image/png',
          metadata: JSON.stringify({
            width: 1024,
            height: 1024,
            style: 'dark gothic horror',
          }),
        },
      });
      
      await this.emitLog(roomId, 'asset', 'success', 'Image generated and uploaded to IPFS!');

      // Code Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'code', 'info', 'Building interactive mini-game from your story...');
      
      // Generate game code using Groq AI
      const gameCode = await this.generateGameCode(storyContent, inputText);
      
      await this.sleep(3000);
      
      // Create code asset with generated game
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'code',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'text/html',
          metadata: JSON.stringify({
            framework: 'html5',
            tests: 'passed',
            gameCode: gameCode,
            generatedFrom: inputText.substring(0, 50),
          }),
        },
      });
      
      await this.emitLog(roomId, 'code', 'success', 'Custom mini-game created and tested!');

      // Deploy Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'deploy', 'info', 'Deploying to Vercel...');
      await this.sleep(3000);
      
      // Create deploy asset
      const deployUrl = `https://haunted-${roomId.substring(0, 8)}.vercel.app`;
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'deploy',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'text/plain',
          metadata: JSON.stringify({
            url: deployUrl,
            status: 'deployed',
          }),
        },
      });
      
      await this.emitLog(roomId, 'deploy', 'success', 'Deployment complete!', {
        url: deployUrl,
      });

      // Complete
      await this.sleep(1000);
      await this.emitLog(roomId, 'orchestrator', 'success', 'ğŸ‰ Workflow completed successfully!');
      await this.updateStatus(roomId, 'done');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      await this.emitLog(roomId, 'orchestrator', 'error', 'Workflow failed: ' + errorMessage);
      await this.updateStatus(roomId, 'error');
    }
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Generate interactive HTML5 game code using Groq AI
   */
  private async generateGameCode(story: string, userInput: string): Promise<string> {
    try {
      const groqApiKey = process.env.GROQ_API_KEY;
      
      if (!groqApiKey || groqApiKey === 'your-groq-api-key-here') {
        // Return demo game if no API key
        return this.getDemoGameCode(userInput);
      }

      // Call Groq API to generate game code
      const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${groqApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'llama-3.3-70b-versatile',
          messages: [
            {
              role: 'system',
              content: 'You are an expert HTML5 game developer. Create a complete, playable horror point-and-click game in a single HTML file with embedded CSS and JavaScript. The game should be atmospheric, interactive, and based on the provided story.',
            },
            {
              role: 'user',
              content: `Create a horror point-and-click game based on this story:\n\n${story.substring(0, 500)}\n\nOriginal idea: ${userInput}\n\nRequirements:\n- Single HTML file with embedded CSS and JavaScript\n- 3-5 clickable rooms/scenes\n- Atmospheric horror theme\n- Simple point-and-click mechanics\n- Creepy sound effects using Web Audio API\n- Responsive design\n- Dark color scheme\n- Return ONLY the complete HTML code, no explanations`,
            },
          ],
          temperature: 0.8,
          max_tokens: 4000,
        }),
      });

      if (!response.ok) {
        throw new Error(`Groq API error: ${response.statusText}`);
      }

      const data: any = await response.json();
      const gameCode = data.choices?.[0]?.message?.content || '';
      
      // Extract HTML if wrapped in markdown code blocks
      const htmlMatch = gameCode.match(/```html\n([\s\S]*?)\n```/) || gameCode.match(/```\n([\s\S]*?)\n```/);
      return htmlMatch ? htmlMatch[1] : gameCode;
      
    } catch (error) {
      console.error('Error generating game code:', error);
      return this.getDemoGameCode(userInput);
    }
  }

  /**
   * Get demo game code as fallback
   */
  private getDemoGameCode(userInput: string): string {
    return `<!DOCTYPE html>
<html><head><meta charset="UTF-8"><title>Horror Game - ${userInput.substring(0, 30)}</title>
<style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:monospace;background:#000;color:#fff;overflow:hidden}#game{width:100vw;height:100vh;position:relative;background:linear-gradient(180deg,#1a0a0a 0%,#000 100%)}.room{width:100%;height:100%;position:absolute;display:none}.room.active{display:block;animation:fadeIn 1s}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.hotspot{position:absolute;width:80px;height:80px;border:2px solid rgba(255,107,0,0.5);border-radius:50%;cursor:pointer;transition:all 0.3s;animation:pulse 2s infinite}.hotspot:hover{border-color:#FF6B00;box-shadow:0 0 20px #FF6B00;transform:scale(1.1)}@keyframes pulse{0%,100%{opacity:0.5;transform:scale(1)}50%{opacity:1;transform:scale(1.05)}}#message{position:absolute;bottom:50px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.9);padding:20px 40px;border:2px solid #FF6B00;border-radius:10px;max-width:600px;text-align:center;font-size:18px}#title{position:absolute;top:30px;left:50%;transform:translateX(-50%);font-size:48px;color:#FF6B00;text-shadow:0 0 20px rgba(255,107,0,0.8);font-weight:bold}</style></head><body><div id="game"><div id="title">ğŸ‘» ${userInput.substring(0, 20).toUpperCase()} ğŸ‘»</div><div id="scene"><div class="room active" id="room1"><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center"><h2 style="font-size:36px;margin-bottom:20px">ğŸšï¸ The Beginning</h2><p style="font-size:20px;margin-bottom:30px">${userInput}</p></div><div class="hotspot" style="bottom:30%;right:40%" onclick="goToRoom(2)"></div></div><div class="room" id="room2"><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center"><h2 style="font-size:36px;margin-bottom:20px">ğŸ•¯ï¸ Deeper</h2><p style="font-size:20px">The darkness grows...</p></div><div class="hotspot" style="top:40%;left:20%" onclick="goToRoom(3)"></div></div><div class="room" id="room3"><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center"><h2 style="font-size:48px;margin-bottom:20px;color:#FF0040">ğŸ‘» THE END ğŸ‘»</h2><p style="font-size:24px;margin-bottom:30px;color:#FF6B00">You discovered the truth...</p><button onclick="location.reload()" style="margin-top:30px;padding:15px 40px;font-size:20px;background:#FF6B00;border:none;border-radius:10px;color:#fff;cursor:pointer">Play Again</button></div></div></div><div id="message">Click the glowing circles to explore...</div></div><script>let currentRoom=1;function goToRoom(n){document.getElementById('room'+currentRoom).classList.remove('active');currentRoom=n;document.getElementById('room'+currentRoom).classList.add('active');const m={1:"Click to explore...",2:"Choose your path...",3:"The truth is revealed..."};document.getElementById('message').textContent=m[n];const a=new AudioContext();const o=a.createOscillator();const g=a.createGain();o.connect(g);g.connect(a.destination);o.frequency.value=200;o.type='sine';g.gain.setValueAtTime(0.3,a.currentTime);g.gain.exponentialRampToValueAtTime(0.01,a.currentTime+0.5);o.start(a.currentTime);o.stop(a.currentTime+0.5)}</script></body></html>`;
  }

  /**
   * Generate a rich, atmospheric horror story from user input
   */
  private generateStoryFromInput(input: string): string {
    // Story templates with different atmospheric elements
    const openings = [
      `ÙÙŠ Ù„ÙŠÙ„Ø© Ø®Ø§Ù„ÙŠØ© Ù…Ù† Ø¶ÙˆØ¡ Ø§Ù„Ù‚Ù…Ø±ØŒ Ø­ÙŠØ« Ø§Ù„Ø¸Ù„Ø§Ù… ÙŠÙ„ØªÙ‡Ù… ÙƒÙ„ Ø´ÙŠØ¡ØŒ ${input}`,
      `ÙƒØ§Ù†Øª Ø§Ù„Ø³Ø§Ø¹Ø© ØªÙ‚ØªØ±Ø¨ Ù…Ù† Ù…Ù†ØªØµÙ Ø§Ù„Ù„ÙŠÙ„ Ø¹Ù†Ø¯Ù…Ø§ ${input}`,
      `Ù„Ù… ÙŠÙƒÙ† Ø£Ø­Ø¯ ÙŠØªÙˆÙ‚Ø¹ Ù…Ø§ Ø³ÙŠØ­Ø¯Ø« ØªÙ„Ùƒ Ø§Ù„Ù„ÙŠÙ„Ø© Ø§Ù„Ù…Ø´Ø¤ÙˆÙ…Ø©ØŒ Ø¹Ù†Ø¯Ù…Ø§ ${input}`,
      `ÙÙŠ Ø£Ø¹Ù…Ø§Ù‚ Ø§Ù„Ø¸Ù„Ø§Ù…ØŒ Ø­ÙŠØ« Ù„Ø§ ÙŠØ¬Ø±Ø¤ Ø£Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø°Ù‡Ø§Ø¨ØŒ ${input}`,
    ];

    const middles = [
      `Ø§Ù„Ø¸Ù„Ø§Ù„ Ø¨Ø¯Ø£Øª ØªØªØ­Ø±Ùƒ Ù…Ù† ØªÙ„Ù‚Ø§Ø¡ Ù†ÙØ³Ù‡Ø§ØŒ ØªØ²Ø­Ù Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† ÙƒØ£Ù†Ù‡Ø§ ÙƒØ§Ø¦Ù†Ø§Øª Ø­ÙŠØ©. ÙƒÙ„ ØµØ±ÙŠØ± Ù„Ù„Ø£Ø±Ø¶ÙŠØ© Ø§Ù„Ø®Ø´Ø¨ÙŠØ© ÙƒØ§Ù† ÙŠØ±Ø³Ù„ Ù‚Ø´Ø¹Ø±ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø§Ù„ÙÙ‚Ø±ÙŠ. Ø§Ù„Ù‡ÙˆØ§Ø¡ Ø£ØµØ¨Ø­ Ø¨Ø§Ø±Ø¯Ù‹Ø§ Ø¨Ø´ÙƒÙ„ ØºÙŠØ± Ø·Ø¨ÙŠØ¹ÙŠØŒ ÙˆØ§Ù„Ø£Ù†ÙØ§Ø³ ØªØªØ­ÙˆÙ„ Ø¥Ù„Ù‰ Ø³Ø­Ø¨ Ø¨ÙŠØ¶Ø§Ø¡ ÙÙŠ Ø§Ù„Ø¸Ù„Ø§Ù….`,
      `Ù‡Ù…Ø³Ø§Øª ØºØ±ÙŠØ¨Ø© Ø¨Ø¯Ø£Øª ØªÙ…Ù„Ø£ Ø§Ù„Ø£Ø¬ÙˆØ§Ø¡ØŒ ÙƒÙ„Ù…Ø§Øª ØºÙŠØ± Ù…ÙÙ‡ÙˆÙ…Ø© Ù…Ù† Ù„ØºØ© Ù…Ù†Ø³ÙŠØ©. Ø§Ù„Ù…Ø±Ø§ÙŠØ§ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† Ø¨Ø¯Ø£Øª ØªØ¹ÙƒØ³ Ø£Ø´ÙŠØ§Ø¡ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„ØºØ±ÙØ©. Ø´ÙŠØ¡ Ù‚Ø¯ÙŠÙ…ØŒ Ø´ÙŠØ¡ Ø´Ø±ÙŠØ±ØŒ ÙƒØ§Ù† ÙŠØ³ØªÙŠÙ‚Ø¸ Ù…Ù† Ø³Ø¨Ø§ØªÙ‡ Ø§Ù„Ø·ÙˆÙŠÙ„.`,
      `Ø§Ù„Ø£Ø¨ÙˆØ§Ø¨ Ø¨Ø¯Ø£Øª ØªÙØªØ­ ÙˆØªØºÙ„Ù‚ Ù…Ù† ØªÙ„Ù‚Ø§Ø¡ Ù†ÙØ³Ù‡Ø§ØŒ ÙˆØ§Ù„Ø£Ø¶ÙˆØ§Ø¡ ØªØ±ØªØ¹Ø´ ÙˆØªØ®ÙØª. Ø±Ø§Ø¦Ø­Ø© ÙƒØ±ÙŠÙ‡Ø© Ù…Ù„Ø£Øª Ø§Ù„Ù…ÙƒØ§Ù†ØŒ Ø±Ø§Ø¦Ø­Ø© Ø§Ù„Ø¹ÙÙ† ÙˆØ§Ù„Ù…ÙˆØª. ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø­Ø¶ÙˆØ±ØŒ Ø´ÙŠØ¡ ÙŠØ±Ø§Ù‚Ø¨ Ù…Ù† Ø§Ù„Ø¸Ù„Ø§Ù„ØŒ ÙŠÙ†ØªØ¸Ø± Ø§Ù„Ù„Ø­Ø¸Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©.`,
      `Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† Ø¨Ø¯Ø£Øª ØªÙ†Ø²ÙØŒ Ø³Ø§Ø¦Ù„ Ø£Ø³ÙˆØ¯ Ù„Ø²Ø¬ ÙŠØªØ¯ÙÙ‚ Ø¨Ø¨Ø·Ø¡. Ø£ØµÙˆØ§Øª Ø®Ø·ÙˆØ§Øª Ø«Ù‚ÙŠÙ„Ø© ØªÙ‚ØªØ±Ø¨ Ù…Ù† Ø§Ù„Ù…Ù…Ø±Ø§Øª Ø§Ù„Ù…Ø¸Ù„Ù…Ø©. Ø§Ù„Ù‚Ù„Ø¨ ÙŠØ¯Ù‚ Ø¨Ø³Ø±Ø¹Ø©ØŒ ÙˆØ§Ù„Ø®ÙˆÙ ÙŠØªØ³Ù„Ù„ Ø¥Ù„Ù‰ ÙƒÙ„ Ø®Ù„ÙŠØ© ÙÙŠ Ø§Ù„Ø¬Ø³Ø¯.`,
    ];

    const climaxes = [
      `ÙˆÙØ¬Ø£Ø©ØŒ Ø¸Ù‡Ø± Ø´Ø¨Ø­ Ù…Ø±Ø¹Ø¨ Ù…Ù† Ø§Ù„Ø¹Ø¯Ù…ØŒ Ø¹ÙŠÙ†Ø§Ù‡ ØªØªÙˆÙ‡Ø¬Ø§Ù† Ø¨Ø¶ÙˆØ¡ Ø£Ø­Ù…Ø± Ø´ÙŠØ·Ø§Ù†ÙŠ. ØµØ±Ø®Ø© Ù…Ø¯ÙˆÙŠØ© Ù…Ù„Ø£Øª Ø§Ù„Ù…ÙƒØ§Ù†ØŒ ØµØ±Ø®Ø© Ù„ÙŠØ³Øª Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¹Ø§Ù„Ù…. Ø§Ù„Ø£Ø±Ø¶ Ø§Ù‡ØªØ²ØªØŒ ÙˆØ§Ù„Ø¬Ø¯Ø±Ø§Ù† Ø¨Ø¯Ø£Øª ØªØªØµØ¯Ø¹.`,
      `ÙÙŠ ØªÙ„Ùƒ Ø§Ù„Ù„Ø­Ø¸Ø©ØŒ Ø§Ù†ÙØªØ­ Ø¨Ø§Ø¨ Ù‚Ø¯ÙŠÙ… Ù„Ù… ÙŠÙÙØªØ­ Ù…Ù†Ø° Ø¹Ù‚ÙˆØ¯. Ù…Ù† Ø®Ù„ÙÙ‡ØŒ Ø®Ø±Ø¬ ÙƒÙŠØ§Ù† Ù…Ø¸Ù„Ù…ØŒ Ø´ÙƒÙ„Ù‡ ÙŠØªØºÙŠØ± Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø¨ÙŠÙ† Ø§Ù„Ø¥Ù†Ø³Ø§Ù† ÙˆØ§Ù„ÙˆØ­Ø´. Ø¹ÙŠÙˆÙ†Ù‡ Ø§Ù„ÙƒØ«ÙŠØ±Ø© ØªØ­Ø¯Ù‚ Ø¨Ø¬ÙˆØ¹ Ù„Ø§ ÙŠÙ†ØªÙ‡ÙŠ.`,
      `Ø§Ù„Ø³Ø§Ø¹Ø© Ø¯Ù‚Øª Ù…Ù†ØªØµÙ Ø§Ù„Ù„ÙŠÙ„ØŒ ÙˆÙÙŠ ØªÙ„Ùƒ Ø§Ù„Ù„Ø­Ø¸Ø© Ø¨Ø§Ù„Ø°Ø§ØªØŒ ØªÙ…Ø²Ù‚ Ø§Ù„Ø­Ø¬Ø§Ø¨ Ø¨ÙŠÙ† Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠÙ†. Ø£Ø±ÙˆØ§Ø­ Ù…Ø¹Ø°Ø¨Ø© Ø¨Ø¯Ø£Øª ØªØ¸Ù‡Ø±ØŒ ÙˆØ¬ÙˆÙ‡Ù‡Ø§ Ù…Ø´ÙˆÙ‡Ø© Ù…Ù† Ø§Ù„Ø£Ù„Ù… ÙˆØ§Ù„ØºØ¶Ø¨. ÙƒØ§Ù†ÙˆØ§ ÙŠØ¨Ø­Ø«ÙˆÙ† Ø¹Ù† Ø´ÙŠØ¡... Ø£Ùˆ Ø¹Ù† Ø´Ø®Øµ.`,
      `Ù…Ù† Ø§Ù„Ø¸Ù„Ø§Ù… Ø§Ù„Ø¯Ø§Ù…Ø³ØŒ Ø§Ù…ØªØ¯Øª ÙŠØ¯ Ø´Ø§Ø­Ø¨Ø©ØŒ Ø£ØµØ§Ø¨Ø¹Ù‡Ø§ Ø·ÙˆÙŠÙ„Ø© ÙˆÙ…Ø®Ø§Ù„Ø¨Ù‡Ø§ Ø­Ø§Ø¯Ø©. ØµÙˆØª Ø¶Ø­ÙƒØ© Ù…Ø¬Ù†ÙˆÙ†Ø© Ù…Ù„Ø£ Ø§Ù„Ø£Ø¬ÙˆØ§Ø¡ØŒ Ø¶Ø­ÙƒØ© ØªØ¬Ù…Ø¯ Ø§Ù„Ø¯Ù… ÙÙŠ Ø§Ù„Ø¹Ø±ÙˆÙ‚. Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù…ÙØ±.`,
    ];

    const endings = [
      `Ø¹Ù†Ø¯Ù…Ø§ Ø·Ù„Ø¹ Ø§Ù„ÙØ¬Ø±ØŒ Ù„Ù… ÙŠØ¨Ù‚ Ø£ÙŠ Ø£Ø«Ø± Ù„Ù…Ø§ Ø­Ø¯Ø« ØªÙ„Ùƒ Ø§Ù„Ù„ÙŠÙ„Ø©. Ù„ÙƒÙ† Ù…Ù† ÙŠØ¹Ø±Ù Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø©ØŒ ÙŠØ¹Ù„Ù… Ø£Ù† Ø§Ù„Ø´Ø± Ù„Ø§ ÙŠÙ…ÙˆØª Ø£Ø¨Ø¯Ù‹Ø§... Ø¥Ù†Ù‡ ÙÙ‚Ø· ÙŠÙ†ØªØ¸Ø±. ÙˆÙÙŠ Ø§Ù„Ù„ÙŠØ§Ù„ÙŠ Ø§Ù„Ù…Ø¸Ù„Ù…Ø©ØŒ Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† Ø§Ù„Ù‚Ù…Ø± ØºØ§Ø¦Ø¨Ù‹Ø§ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø£Ù† ØªØ³Ù…Ø¹ Ø§Ù„Ù‡Ù…Ø³Ø§Øª Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ØŒ ØªÙ†Ø§Ø¯ÙŠÙƒØŒ ØªØ¯Ø¹ÙˆÙƒ Ù„Ù„Ø¹ÙˆØ¯Ø©...`,
      `Ù„Ù… ÙŠÙØ¹Ø«Ø± Ø¹Ù„Ù‰ Ø£ÙŠ Ø´ÙŠØ¡ ÙÙŠ Ø§Ù„ØµØ¨Ø§Ø­ Ø³ÙˆÙ‰ Ø¢Ø«Ø§Ø± Ø£Ù‚Ø¯Ø§Ù… ØºØ±ÙŠØ¨Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¶ØŒ ÙˆØ¨Ù‚Ø¹ Ù…Ù† Ø³Ø§Ø¦Ù„ Ø£Ø³ÙˆØ¯ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªÙØ³ÙŠØ±Ù‡. Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ù…Ø­Ù„ÙŠÙˆÙ† ÙŠØªØ¬Ù†Ø¨ÙˆÙ† Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ø¢Ù†ØŒ ÙˆÙŠØ­Ø°Ø±ÙˆÙ† Ø§Ù„ØºØ±Ø¨Ø§Ø¡ Ù…Ù† Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨. Ù„ÙƒÙ† Ø§Ù„ÙØ¶ÙˆÙ„ÙŠÙŠÙ† Ø¯Ø§Ø¦Ù…Ù‹Ø§ ÙŠØ£ØªÙˆÙ†... ÙˆÙ„Ø§ ÙŠØ¹ÙˆØ¯ÙˆÙ† Ø£Ø¨Ø¯Ù‹Ø§.`,
      `Ø§Ù„Ø¢Ù†ØŒ ÙƒÙ„Ù…Ø§ Ù…Ø± Ø£Ø­Ø¯ Ø¨Ø°Ù„Ùƒ Ø§Ù„Ù…ÙƒØ§Ù† ÙÙŠ Ø§Ù„Ù„ÙŠÙ„ØŒ ÙŠØ´Ø¹Ø± Ø¨Ù†Ø¸Ø±Ø§Øª ØªØ±Ø§Ù‚Ø¨Ù‡ Ù…Ù† Ø§Ù„Ù†ÙˆØ§ÙØ° Ø§Ù„Ù…Ø¸Ù„Ù…Ø©. Ø§Ù„Ø¨Ø¹Ø¶ ÙŠÙ‚Ø³Ù… Ø£Ù†Ù‡Ù… Ø±Ø£ÙˆØ§ Ø£Ø´Ø¨Ø§Ø­Ù‹Ø§ ØªØªØ­Ø±Ùƒ ÙÙŠ Ø§Ù„Ø¯Ø§Ø®Ù„. ÙˆØ§Ù„Ø¨Ø¹Ø¶ Ø§Ù„Ø¢Ø®Ø±... Ø§Ø®ØªÙÙ‰ Ø¨Ø¨Ø³Ø§Ø·Ø©. Ø§Ù„Ù‚ØµØ© Ù„Ù… ØªÙ†ØªÙ‡ Ø¨Ø¹Ø¯ØŒ Ø¥Ù†Ù‡Ø§ ÙÙ‚Ø· Ø¨Ø¯Ø£Øª.`,
      `Ù…Ù†Ø° ØªÙ„Ùƒ Ø§Ù„Ù„ÙŠÙ„Ø©ØŒ ØªØºÙŠØ± ÙƒÙ„ Ø´ÙŠØ¡. Ø§Ù„Ø¸Ù„Ø§Ù… Ø£ØµØ¨Ø­ Ø£ÙƒØ«Ø± ÙƒØ«Ø§ÙØ©ØŒ ÙˆØ§Ù„ØµÙ…Øª Ø£ÙƒØ«Ø± Ø±Ø¹Ø¨Ù‹Ø§. Ù…Ù† ÙŠØ¬Ø±Ø¤ Ø¹Ù„Ù‰ Ø¯Ø®ÙˆÙ„ Ø°Ù„Ùƒ Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ø¢Ù†ØŒ ÙŠØ®Ø±Ø¬ Ù…Ø®ØªÙ„ÙÙ‹Ø§... Ø¥Ù† Ø®Ø±Ø¬ Ø£ØµÙ„Ø§Ù‹. Ø§Ù„Ø´Ø± Ø§Ù„Ø°ÙŠ Ø§Ø³ØªÙŠÙ‚Ø¸ ØªÙ„Ùƒ Ø§Ù„Ù„ÙŠÙ„Ø© Ù„Ø§ ÙŠØ²Ø§Ù„ Ù‡Ù†Ø§ÙƒØŒ ÙŠÙ†ØªØ¸Ø± Ø¶Ø­ÙŠØªÙ‡ Ø§Ù„ØªØ§Ù„ÙŠØ©. ÙˆØ±Ø¨Ù…Ø§... ØªÙƒÙˆÙ† Ø£Ù†Øª.`,
    ];

    // Randomly select elements to create variety
    const opening = openings[Math.floor(Math.random() * openings.length)];
    const middle = middles[Math.floor(Math.random() * middles.length)];
    const climax = climaxes[Math.floor(Math.random() * climaxes.length)];
    const ending = endings[Math.floor(Math.random() * endings.length)];

    return `${opening}\n\n${middle}\n\n${climax}\n\n${ending}`;
  }

  /**
   * Emit log message to room via Redis pub/sub
   * Requirements: 5.1
   */
  async emitLog(
    roomId: string,
    agentType: AgentLog['agentType'],
    level: AgentLog['level'],
    message: string,
    metadata?: Record<string, any>,
  ): Promise<void> {
    const log: AgentLog = {
      timestamp: new Date(),
      agentType,
      level,
      message,
      metadata,
    };

    await this.redisService.publishLog(roomId, log);
  }
}
