// Generated by Kiro
import { Injectable, NotFoundException, Inject, forwardRef } from '@nestjs/common';

import { PrismaService } from '../../prisma/prisma.service';

import { CreateRoomDto } from './dto/create-room.dto';
import { RedisService } from './redis.service';
import { AgentLog } from './types/agent-log.types';

@Injectable()
export class RoomsService {
  constructor(
    private prisma: PrismaService,
    @Inject(forwardRef(() => RedisService))
    private redisService: RedisService,
  ) {}

  /**
   * Create a new room
   * Requirements: 8.1, 8.2
   */
  async create(createRoomDto: CreateRoomDto & { userId: string }) {
    // Verify user exists
    const user = await this.prisma.user.findUnique({
      where: { id: createRoomDto.userId },
    });

    if (!user) {
      throw new Error('User not found');
    }

    const room = await this.prisma.room.create({
      data: {
        ownerId: createRoomDto.userId,
        inputText: createRoomDto.inputText,
        status: 'idle',
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            did: true,
          },
        },
      },
    });

    return room;
  }

  /**
   * Get room by ID
   * Requirements: 8.3
   */
  async findOne(id: string) {
    const room = await this.prisma.room.findUnique({
      where: { id },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            did: true,
          },
        },
        assets: {
          orderBy: {
            createdAt: 'asc',
          },
        },
      },
    });

    if (!room) {
      throw new NotFoundException(`Room with ID ${id} not found`);
    }

    return room;
  }

  /**
   * Get all rooms for a user
   * Requirements: 8.3
   */
  async findByUser(userId: string) {
    const rooms = await this.prisma.room.findMany({
      where: { ownerId: userId },
      include: {
        assets: {
          select: {
            id: true,
            agentType: true,
            cid: true,
            createdAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return rooms;
  }

  /**
   * Start agent workflow for a room
   * Requirements: 8.3
   */
  async startWorkflow(id: string) {
    // Check if room exists
    const room = await this.prisma.room.findUnique({
      where: { id },
    });

    if (!room) {
      throw new NotFoundException(`Room with ID ${id} not found`);
    }

    // Update room status to running
    const updatedRoom = await this.prisma.room.update({
      where: { id },
      data: {
        status: 'running',
        updatedAt: new Date(),
      },
      include: {
        owner: {
          select: {
            id: true,
            username: true,
            did: true,
          },
        },
      },
    });

    // Trigger mock workflow (simulates agent execution)
    this.simulateWorkflow(id, room.inputText).catch((error) => {
      console.error('Workflow simulation error:', error);
    });

    return {
      ...updatedRoom,
      message: 'Workflow started successfully',
    };
  }

  /**
   * Update room status
   * Requirements: 8.4, 8.5
   */
  async updateStatus(id: string, status: 'idle' | 'running' | 'done' | 'error', errorMessage?: string) {
    const room = await this.prisma.room.findUnique({
      where: { id },
    });

    if (!room) {
      throw new NotFoundException(`Room with ID ${id} not found`);
    }

    const updatedRoom = await this.prisma.room.update({
      where: { id },
      data: {
        status,
        updatedAt: new Date(),
      },
    });

    return updatedRoom;
  }

  /**
   * Simulate workflow execution (mock implementation)
   */
  private async simulateWorkflow(roomId: string, inputText: string): Promise<void> {
    try {
      // Story Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'story', 'info', 'Generating spooky story from your input...');
      await this.sleep(3000);
      
      // Generate rich story content based on user input
      const storyContent = this.generateStoryFromInput(inputText);
      
      // Create story asset with content in metadata
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'story',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'text/plain',
          metadata: JSON.stringify({
            content: storyContent,
            wordCount: storyContent.split(/\s+/).length,
            theme: 'haunted',
          }),
        },
      });
      
      await this.emitLog(roomId, 'story', 'success', 'Story generated successfully!', {
        length: storyContent.length,
        wordCount: storyContent.split(/\s+/).length,
      });

      // Asset Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'asset', 'info', 'Creating haunting image for your story...');
      await this.sleep(4000);
      
      // Create image asset
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'asset',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'image/png',
          metadata: JSON.stringify({
            width: 1024,
            height: 1024,
            style: 'dark gothic horror',
          }),
        },
      });
      
      await this.emitLog(roomId, 'asset', 'success', 'Image generated and uploaded to IPFS!');

      // Code Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'code', 'info', 'Building interactive mini-game...');
      await this.sleep(5000);
      
      // Create code asset
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'code',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'application/zip',
          metadata: JSON.stringify({
            framework: 'html5',
            tests: 'passed',
          }),
        },
      });
      
      await this.emitLog(roomId, 'code', 'success', 'Mini-game created and tested!');

      // Deploy Agent
      await this.sleep(2000);
      await this.emitLog(roomId, 'deploy', 'info', 'Deploying to Vercel...');
      await this.sleep(3000);
      
      // Create deploy asset
      const deployUrl = `https://haunted-${roomId.substring(0, 8)}.vercel.app`;
      await this.prisma.asset.create({
        data: {
          roomId,
          agentType: 'deploy',
          cid: 'bafybeig' + Math.random().toString(36).substring(7),
          fileType: 'text/plain',
          metadata: JSON.stringify({
            url: deployUrl,
            status: 'deployed',
          }),
        },
      });
      
      await this.emitLog(roomId, 'deploy', 'success', 'Deployment complete!', {
        url: deployUrl,
      });

      // Complete
      await this.sleep(1000);
      await this.emitLog(roomId, 'orchestrator', 'success', 'ðŸŽ‰ Workflow completed successfully!');
      await this.updateStatus(roomId, 'done');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      await this.emitLog(roomId, 'orchestrator', 'error', 'Workflow failed: ' + errorMessage);
      await this.updateStatus(roomId, 'error');
    }
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Emit log message to room via Redis pub/sub
   * Requirements: 5.1
   */
  async emitLog(
    roomId: string,
    agentType: AgentLog['agentType'],
    level: AgentLog['level'],
    message: string,
    metadata?: Record<string, any>,
  ): Promise<void> {
    const log: AgentLog = {
      timestamp: new Date(),
      agentType,
      level,
      message,
      metadata,
    };

    await this.redisService.publishLog(roomId, log);
  }
}
