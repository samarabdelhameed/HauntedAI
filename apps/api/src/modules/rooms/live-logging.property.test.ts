// Generated by Kiro - Property-Based Tests for Live Logging
// Feature: haunted-ai
// Validates: Requirements 5.1, 5.2, 5.5
import { Test, TestingModule } from '@nestjs/testing';
import * as fc from 'fast-check';

import { PrismaService } from '../../prisma/prisma.service';

import { RedisService } from './redis.service';
import { RoomsService } from './rooms.service';
import { SSEService } from './sse.service';
import { AgentLog } from './types/agent-log.types';

describe('Live Logging Property-Based Tests', () => {
  let roomsService: RoomsService;
  let redisService: RedisService;
  let sseService: SSEService;
  let prismaService: PrismaService;
  let module: TestingModule;

  beforeEach(async () => {
    module = await Test.createTestingModule({
      providers: [
        RoomsService,
        SSEService,
        {
          provide: RedisService,
          useValue: {
            publishLog: jest.fn(),
            subscribeToRoomLogs: jest.fn(),
          },
        },
        {
          provide: PrismaService,
          useValue: {
            room: {
              create: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    roomsService = module.get<RoomsService>(RoomsService);
    redisService = module.get<RedisService>(RedisService);
    sseService = module.get<SSEService>(SSEService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Feature: haunted-ai, Property 15: Agent operations emit logs
  // Validates: Requirements 5.1
  describe('Property 15: Agent operations emit logs', () => {
    it('should emit log within 100ms for any agent operation', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            agentType: fc.constantFrom('story', 'asset', 'code', 'deploy', 'orchestrator'),
            level: fc.constantFrom('info', 'warn', 'error', 'success'),
            message: fc.string({ minLength: 1, maxLength: 200 }),
            metadata: fc.option(
              fc.dictionary(
                fc.string({ minLength: 1, maxLength: 20 }),
                fc.oneof(
                  fc.string(),
                  fc.integer(),
                  fc.boolean(),
                ),
              ),
              { nil: undefined },
            ),
          }),
          async ({ roomId, agentType, level, message, metadata }) => {
            // Reset mock before each iteration
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            const startTime = Date.now();
            
            // Emit log
            await roomsService.emitLog(roomId, agentType, level, message, metadata);
            
            const endTime = Date.now();
            const duration = endTime - startTime;

            // Property: Log should be emitted within 100ms
            expect(duration).toBeLessThan(100);

            // Property: publishLog should be called exactly once
            expect(publishLogSpy).toHaveBeenCalledTimes(1);

            // Property: publishLog should be called with correct parameters
            expect(publishLogSpy).toHaveBeenCalledWith(
              roomId,
              expect.objectContaining({
                timestamp: expect.any(Date),
                agentType,
                level,
                message,
                metadata,
              }),
            );
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should emit logs for all valid agent types', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            agentType: fc.constantFrom('story', 'asset', 'code', 'deploy', 'orchestrator'),
            message: fc.string({ minLength: 1, maxLength: 200 }),
          }),
          async ({ roomId, agentType, message }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            await roomsService.emitLog(roomId, agentType, 'info', message);

            // Property: All valid agent types should be supported
            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            expect(publishLogSpy).toHaveBeenCalledWith(
              roomId,
              expect.objectContaining({
                agentType,
              }),
            );
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should emit logs for all valid log levels', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            level: fc.constantFrom('info', 'warn', 'error', 'success'),
            message: fc.string({ minLength: 1, maxLength: 200 }),
          }),
          async ({ roomId, level, message }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            await roomsService.emitLog(roomId, 'orchestrator', level, message);

            // Property: All valid log levels should be supported
            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            expect(publishLogSpy).toHaveBeenCalledWith(
              roomId,
              expect.objectContaining({
                level,
              }),
            );
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should include timestamp in emitted logs', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            message: fc.string({ minLength: 1, maxLength: 200 }),
          }),
          async ({ roomId, message }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            const beforeEmit = Date.now() - 10; // Add small buffer for timing
            await roomsService.emitLog(roomId, 'orchestrator', 'info', message);
            const afterEmit = Date.now() + 10; // Add small buffer for timing

            // Property: Timestamp should be set and within reasonable range
            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            expect(publishLogSpy).toHaveBeenCalledWith(
              roomId,
              expect.objectContaining({
                timestamp: expect.any(Date),
              }),
            );

            const emittedLog = publishLogSpy.mock.calls[0][1] as AgentLog;
            expect(emittedLog.timestamp.getTime()).toBeGreaterThanOrEqual(beforeEmit);
            expect(emittedLog.timestamp.getTime()).toBeLessThanOrEqual(afterEmit);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 16: Log message rendering completeness
  // Validates: Requirements 5.2
  describe('Property 16: Log message rendering completeness', () => {
    it('should include both timestamp and agent type in all logs', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            agentType: fc.constantFrom('story', 'asset', 'code', 'deploy', 'orchestrator'),
            level: fc.constantFrom('info', 'warn', 'error', 'success'),
            message: fc.string({ minLength: 1, maxLength: 200 }),
          }),
          async ({ roomId, agentType, level, message }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            await roomsService.emitLog(roomId, agentType, level, message);

            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            const emittedLog = publishLogSpy.mock.calls[0][1] as AgentLog;

            // Property: Log must contain timestamp
            expect(emittedLog.timestamp).toBeDefined();
            expect(emittedLog.timestamp).toBeInstanceOf(Date);

            // Property: Log must contain agent type
            expect(emittedLog.agentType).toBeDefined();
            expect(emittedLog.agentType).toBe(agentType);

            // Property: Timestamp should be valid ISO string when serialized
            const isoTimestamp = emittedLog.timestamp.toISOString();
            expect(isoTimestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should include all required fields in log structure', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            agentType: fc.constantFrom('story', 'asset', 'code', 'deploy', 'orchestrator'),
            level: fc.constantFrom('info', 'warn', 'error', 'success'),
            message: fc.string({ minLength: 1, maxLength: 200 }),
            metadata: fc.option(
              fc.dictionary(fc.string(), fc.string()),
              { nil: undefined },
            ),
          }),
          async ({ roomId, agentType, level, message, metadata }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            await roomsService.emitLog(roomId, agentType, level, message, metadata);

            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            const emittedLog = publishLogSpy.mock.calls[0][1] as AgentLog;

            // Property: Log must have all required fields
            expect(emittedLog).toHaveProperty('timestamp');
            expect(emittedLog).toHaveProperty('agentType');
            expect(emittedLog).toHaveProperty('level');
            expect(emittedLog).toHaveProperty('message');

            // Property: Required fields must have correct types
            expect(typeof emittedLog.agentType).toBe('string');
            expect(typeof emittedLog.level).toBe('string');
            expect(typeof emittedLog.message).toBe('string');

            // Property: Metadata is optional but if provided, should be preserved
            if (metadata !== undefined) {
              expect(emittedLog.metadata).toEqual(metadata);
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should preserve message content exactly', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            message: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, message }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            await roomsService.emitLog(roomId, 'orchestrator', 'info', message);

            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            const emittedLog = publishLogSpy.mock.calls[0][1] as AgentLog;

            // Property: Message content should be preserved exactly
            expect(emittedLog.message).toBe(message);
            expect(emittedLog.message.length).toBe(message.length);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle special characters in messages', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            message: fc.string({ minLength: 1, maxLength: 200 }),
          }),
          async ({ roomId, message }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            await roomsService.emitLog(roomId, 'orchestrator', 'info', message);

            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            const emittedLog = publishLogSpy.mock.calls[0][1] as AgentLog;

            // Property: Special characters should be preserved
            expect(emittedLog.message).toBe(message);

            // Property: Log should be JSON serializable
            expect(() => JSON.stringify(emittedLog)).not.toThrow();
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 19: Log buffer size limit
  // Validates: Requirements 5.5
  describe('Property 19: Log buffer size limit', () => {
    it('should handle sequences of logs correctly', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            logCount: fc.integer({ min: 1, max: 150 }),
          }),
          async ({ roomId, logCount }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            // Emit multiple logs
            for (let i = 0; i < logCount; i++) {
              await roomsService.emitLog(
                roomId,
                'orchestrator',
                'info',
                `Log message ${i + 1}`,
              );
            }

            // Property: All logs should be published
            expect(publishLogSpy).toHaveBeenCalledTimes(logCount);

            // Property: Each log should have unique timestamp or message
            const calls = publishLogSpy.mock.calls;
            for (let i = 0; i < calls.length; i++) {
              const log = calls[i][1] as AgentLog;
              expect(log.message).toContain(`Log message ${i + 1}`);
            }
          }
        ),
        { numRuns: 50 }
      );
    });

    it('should maintain log order in sequence', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            logCount: fc.integer({ min: 5, max: 20 }),
          }),
          async ({ roomId, logCount }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            const messages: string[] = [];
            
            // Emit logs sequentially
            for (let i = 0; i < logCount; i++) {
              const message = `Sequential log ${i}`;
              messages.push(message);
              await roomsService.emitLog(roomId, 'orchestrator', 'info', message);
            }

            // Property: Logs should be published in order
            const calls = publishLogSpy.mock.calls;
            expect(calls.length).toBe(logCount);
            for (let i = 0; i < calls.length; i++) {
              const log = calls[i][1] as AgentLog;
              expect(log.message).toBe(messages[i]);
            }
          }
        ),
        { numRuns: 50 }
      );
    });

    it('should handle rapid log emission', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            burstSize: fc.integer({ min: 10, max: 50 }),
          }),
          async ({ roomId, burstSize }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            // Emit logs rapidly (simulating burst)
            const promises = [];
            for (let i = 0; i < burstSize; i++) {
              promises.push(
                roomsService.emitLog(
                  roomId,
                  'orchestrator',
                  'info',
                  `Burst log ${i}`,
                )
              );
            }

            await Promise.all(promises);

            // Property: All logs should be published even in burst
            expect(publishLogSpy).toHaveBeenCalledTimes(burstSize);

            // Property: Each log should be unique
            const messages = new Set<string>();
            publishLogSpy.mock.calls.forEach(call => {
              const log = call[1] as AgentLog;
              messages.add(log.message);
            });
            expect(messages.size).toBe(burstSize);
          }
        ),
        { numRuns: 50 }
      );
    });

    it('should handle logs exceeding buffer limit conceptually', async () => {
      // Note: This test validates the log emission behavior
      // The actual buffer limit of 100 messages is enforced client-side
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            logCount: fc.integer({ min: 100, max: 120 }),
          }),
          async ({ roomId, logCount }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            // Emit more than 100 logs
            for (let i = 0; i < logCount; i++) {
              await roomsService.emitLog(
                roomId,
                'orchestrator',
                'info',
                `Log ${i}`,
              );
            }

            // Property: Server should emit all logs (client handles buffer limit)
            expect(publishLogSpy).toHaveBeenCalledTimes(logCount);

            // Property: All logs should have valid structure
            publishLogSpy.mock.calls.forEach(call => {
              const log = call[1] as AgentLog;
              expect(log).toHaveProperty('timestamp');
              expect(log).toHaveProperty('agentType');
              expect(log).toHaveProperty('level');
              expect(log).toHaveProperty('message');
            });
          }
        ),
        { numRuns: 30 }
      );
    });
  });

  // Additional property: Log metadata preservation
  describe('Additional Property: Metadata preservation', () => {
    it('should preserve complex metadata structures', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            metadata: fc.dictionary(
              fc.string({ minLength: 1, maxLength: 20 }),
              fc.oneof(
                fc.string(),
                fc.integer(),
                fc.boolean(),
                fc.constant(null),
              ),
            ),
          }),
          async ({ roomId, metadata }) => {
            jest.clearAllMocks();
            const publishLogSpy = jest.spyOn(redisService, 'publishLog').mockResolvedValue();

            await roomsService.emitLog(
              roomId,
              'orchestrator',
              'info',
              'Test message',
              metadata,
            );

            expect(publishLogSpy).toHaveBeenCalledTimes(1);
            const emittedLog = publishLogSpy.mock.calls[0][1] as AgentLog;

            // Property: Metadata should be preserved exactly
            expect(emittedLog.metadata).toEqual(metadata);

            // Property: Metadata should be JSON serializable
            expect(() => JSON.stringify(emittedLog.metadata)).not.toThrow();
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
