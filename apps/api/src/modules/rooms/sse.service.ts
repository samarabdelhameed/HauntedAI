// Generated by Kiro
// Server-Sent Events service for live log streaming
// Managed by Kiro - Part of HauntedAI real-time logging system
import { Injectable, Logger } from '@nestjs/common';
import { Response } from 'express';

import { RedisService } from './redis.service';
import { AgentLog } from './types/agent-log.types';

interface SSEConnection {
  roomId: string;
  response: Response;
  unsubscribe: () => Promise<void>;
  heartbeatInterval: ReturnType<typeof setInterval>;
}

@Injectable()
export class SSEService {
  private readonly logger = new Logger(SSEService.name);
  private connections: Map<string, SSEConnection> = new Map();

  constructor(private readonly redisService: RedisService) {}

  /**
   * Create SSE connection for room logs
   * Requirements: 5.1, 5.2
   */
  async createConnection(roomId: string, res: Response): Promise<void> {
    // Set SSE headers
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering

    // Send initial connection message
    this.sendEvent(res, 'connected', { roomId, timestamp: new Date().toISOString() });

    // Subscribe to Redis channel for this room
    const unsubscribe = await this.redisService.subscribeToRoomLogs(
      roomId,
      (log: AgentLog) => {
        this.sendEvent(res, 'log', log);
      },
    );

    // Set up heartbeat to keep connection alive
    // Requirements: Connection management and heartbeat
    const heartbeatInterval = setInterval(() => {
      this.sendEvent(res, 'heartbeat', { timestamp: new Date().toISOString() });
    }, 30000); // Send heartbeat every 30 seconds

    // Store connection
    const connectionId = `${roomId}-${Date.now()}`;
    this.connections.set(connectionId, {
      roomId,
      response: res,
      unsubscribe,
      heartbeatInterval,
    });

    this.logger.log(`SSE connection established for room ${roomId}`);

    // Handle client disconnect
    res.on('close', async () => {
      await this.closeConnection(connectionId);
    });

    // Handle errors
    res.on('error', async (error) => {
      this.logger.error(`SSE connection error for room ${roomId}:`, error);
      await this.closeConnection(connectionId);
    });
  }

  /**
   * Send SSE event to client
   * Requirements: 5.2
   */
  private sendEvent(res: Response, event: string, data: any): void {
    try {
      const payload = JSON.stringify(data);
      res.write(`event: ${event}\n`);
      res.write(`data: ${payload}\n\n`);
    } catch (error) {
      this.logger.error('Failed to send SSE event:', error);
    }
  }

  /**
   * Close SSE connection
   * Requirements: Connection management
   */
  private async closeConnection(connectionId: string): Promise<void> {
    const connection = this.connections.get(connectionId);
    
    if (connection) {
      // Clear heartbeat interval
      clearInterval(connection.heartbeatInterval);

      // Unsubscribe from Redis
      try {
        await connection.unsubscribe();
      } catch (error) {
        this.logger.error('Failed to unsubscribe from Redis:', error);
      }

      // End response
      try {
        connection.response.end();
      } catch (error) {
        // Response may already be closed
      }

      // Remove from connections map
      this.connections.delete(connectionId);

      this.logger.log(`SSE connection closed for room ${connection.roomId}`);
    }
  }

  /**
   * Close all connections for a room
   */
  async closeRoomConnections(roomId: string): Promise<void> {
    const connectionsToClose: string[] = [];

    for (const [connectionId, connection] of this.connections.entries()) {
      if (connection.roomId === roomId) {
        connectionsToClose.push(connectionId);
      }
    }

    for (const connectionId of connectionsToClose) {
      await this.closeConnection(connectionId);
    }
  }

  /**
   * Get active connection count
   */
  getActiveConnectionCount(): number {
    return this.connections.size;
  }

  /**
   * Get active connections for a room
   */
  getRoomConnectionCount(roomId: string): number {
    let count = 0;
    for (const connection of this.connections.values()) {
      if (connection.roomId === roomId) {
        count++;
      }
    }
    return count;
  }
}
