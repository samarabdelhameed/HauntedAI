// Generated by Kiro - Property-Based Tests
import { Test, TestingModule } from '@nestjs/testing';
import * as fc from 'fast-check';

import { PrismaService } from '../../prisma/prisma.service';

import { RedisService } from './redis.service';
import { RoomsService } from './rooms.service';

// Room status enum values
const RoomStatus = {
  idle: 'idle' as const,
  running: 'running' as const,
  done: 'done' as const,
  error: 'error' as const,
};

describe('Room Management Property-Based Tests', () => {
  let service: RoomsService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        RoomsService,
        {
          provide: PrismaService,
          useValue: {
            room: {
              create: jest.fn(),
              findUnique: jest.fn(),
              findMany: jest.fn(),
              update: jest.fn(),
            },
          },
        },
        {
          provide: RedisService,
          useValue: {
            publish: jest.fn(),
            subscribe: jest.fn(),
            getClient: jest.fn(() => ({
              publish: jest.fn(),
            })),
          },
        },
      ],
    }).compile();

    service = module.get<RoomsService>(RoomsService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  // Feature: haunted-ai, Property 27: Room creation uniqueness
  // Validates: Requirements 8.1
  describe('Property 27: Room creation uniqueness', () => {
    it('should create rooms with unique UUIDs', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(
            fc.record({
              userId: fc.string({ minLength: 5, maxLength: 50 }),
              inputText: fc.string({ minLength: 1, maxLength: 500 }),
            }),
            { minLength: 1, maxLength: 10 }
          ),
          async (roomRequests) => {
            const createdRoomIds = new Set<string>();

            for (const request of roomRequests) {
              const mockRoom = {
                id: `room-${Date.now()}-${Math.random().toString(36).substring(7)}`,
                ownerId: request.userId,
                status: RoomStatus.idle,
                inputText: request.inputText,
                createdAt: new Date(),
                updatedAt: new Date(),
                owner: {
                  id: request.userId,
                  username: `user_${request.userId.slice(0, 6)}`,
                  did: `did:ethr:0x${request.userId}`,
                },
              };

              jest.spyOn(prismaService.room, 'create').mockResolvedValueOnce(mockRoom as any);

              const result = await service.create(request);

              // Property: Each room should have a unique ID
              expect(createdRoomIds.has(result.id)).toBe(false);
              createdRoomIds.add(result.id);
            }

            // Verify all IDs are unique
            expect(createdRoomIds.size).toBe(roomRequests.length);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should generate valid UUID format for room IDs', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.string({ minLength: 5, maxLength: 50 }),
            inputText: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async (request) => {
            const mockRoom = {
              id: `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`,
              ownerId: request.userId,
              status: RoomStatus.idle,
              inputText: request.inputText,
              createdAt: new Date(),
              updatedAt: new Date(),
              owner: {
                id: request.userId,
                username: `user_${request.userId.slice(0, 6)}`,
                did: `did:ethr:0x${request.userId}`,
              },
            };

            jest.spyOn(prismaService.room, 'create').mockResolvedValue(mockRoom as any);

            const result = await service.create(request);

            // Property: Room ID should be a non-empty string
            expect(result.id).toBeTruthy();
            expect(typeof result.id).toBe('string');
            expect(result.id.length).toBeGreaterThan(0);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 28: New room initial state
  // Validates: Requirements 8.2
  describe('Property 28: New room initial state', () => {
    it('should create all rooms with idle status', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.string({ minLength: 5, maxLength: 50 }),
            inputText: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async (request) => {
            const mockRoom = {
              id: `room-${Date.now()}`,
              ownerId: request.userId,
              status: RoomStatus.idle,
              inputText: request.inputText,
              createdAt: new Date(),
              updatedAt: new Date(),
              owner: {
                id: request.userId,
                username: `user_${request.userId.slice(0, 6)}`,
                did: `did:ethr:0x${request.userId}`,
              },
            };

            jest.spyOn(prismaService.room, 'create').mockResolvedValue(mockRoom as any);

            const result = await service.create(request);

            // Property: All newly created rooms should have status "idle"
            expect(result.status).toBe(RoomStatus.idle);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should preserve input text exactly as provided', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.string({ minLength: 5, maxLength: 50 }),
            inputText: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async (request) => {
            const mockRoom = {
              id: `room-${Date.now()}`,
              ownerId: request.userId,
              status: RoomStatus.idle,
              inputText: request.inputText,
              createdAt: new Date(),
              updatedAt: new Date(),
              owner: {
                id: request.userId,
                username: `user_${request.userId.slice(0, 6)}`,
                did: `did:ethr:0x${request.userId}`,
              },
            };

            jest.spyOn(prismaService.room, 'create').mockResolvedValue(mockRoom as any);

            const result = await service.create(request);

            // Property: Input text should be stored exactly as provided
            expect(result.inputText).toBe(request.inputText);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should set timestamps on room creation', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.string({ minLength: 5, maxLength: 50 }),
            inputText: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async (request) => {
            const now = new Date();
            const mockRoom = {
              id: `room-${Date.now()}`,
              ownerId: request.userId,
              status: RoomStatus.idle,
              inputText: request.inputText,
              createdAt: now,
              updatedAt: now,
              owner: {
                id: request.userId,
                username: `user_${request.userId.slice(0, 6)}`,
                did: `did:ethr:0x${request.userId}`,
              },
            };

            jest.spyOn(prismaService.room, 'create').mockResolvedValue(mockRoom as any);

            const result = await service.create(request);

            // Property: Timestamps should be set
            expect(result.createdAt).toBeInstanceOf(Date);
            expect(result.updatedAt).toBeInstanceOf(Date);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 29: Room status transitions
  // Validates: Requirements 8.3, 8.4, 8.5
  describe('Property 29: Room status transitions', () => {
    it('should transition from idle to running when workflow starts', async () => {
      await fc.assert(
        fc.asyncProperty(fc.string({ minLength: 5, maxLength: 50 }), async (roomId) => {
          const mockIdleRoom = {
            id: roomId,
            ownerId: 'user-123',
            status: RoomStatus.idle,
            inputText: 'Test input',
            createdAt: new Date(),
            updatedAt: new Date(),
          };

          const mockRunningRoom = {
            ...mockIdleRoom,
            status: RoomStatus.running,
            owner: {
              id: 'user-123',
              username: 'testuser',
              did: 'did:ethr:0x123',
            },
          };

          jest.spyOn(prismaService.room, 'findUnique').mockResolvedValue(mockIdleRoom as any);
          jest.spyOn(prismaService.room, 'update').mockResolvedValue(mockRunningRoom as any);

          const result = await service.startWorkflow(roomId);

          // Property: Status should transition from idle to running
          expect(result.status).toBe(RoomStatus.running);
        }),
        { numRuns: 100 }
      );
    });

    it('should transition from running to done', async () => {
      await fc.assert(
        fc.asyncProperty(fc.string({ minLength: 5, maxLength: 50 }), async (roomId) => {
          const mockRunningRoom = {
            id: roomId,
            ownerId: 'user-123',
            status: RoomStatus.running,
            inputText: 'Test input',
            createdAt: new Date(),
            updatedAt: new Date(),
          };

          const mockDoneRoom = {
            ...mockRunningRoom,
            status: RoomStatus.done,
          };

          jest.spyOn(prismaService.room, 'findUnique').mockResolvedValue(mockRunningRoom as any);
          jest.spyOn(prismaService.room, 'update').mockResolvedValue(mockDoneRoom as any);

          const result = await service.updateStatus(roomId, RoomStatus.done);

          // Property: Status should transition from running to done
          expect(result.status).toBe(RoomStatus.done);
        }),
        { numRuns: 100 }
      );
    });

    it('should transition from running to error on failure', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            errorMessage: fc.string({ minLength: 1, maxLength: 200 }),
          }),
          async ({ roomId, errorMessage }) => {
            const mockRunningRoom = {
              id: roomId,
              ownerId: 'user-123',
              status: RoomStatus.running,
              inputText: 'Test input',
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            const mockErrorRoom = {
              ...mockRunningRoom,
              status: RoomStatus.error,
            };

            jest.spyOn(prismaService.room, 'findUnique').mockResolvedValue(mockRunningRoom as any);
            jest.spyOn(prismaService.room, 'update').mockResolvedValue(mockErrorRoom as any);

            const result = await service.updateStatus(roomId, RoomStatus.error, errorMessage);

            // Property: Status should transition from running to error
            expect(result.status).toBe(RoomStatus.error);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain valid status values throughout lifecycle', async () => {
      await fc.assert(
        fc.asyncProperty(fc.string({ minLength: 5, maxLength: 50 }), async (roomId) => {
          const validStatuses = [RoomStatus.idle, RoomStatus.running, RoomStatus.done, RoomStatus.error];

          for (const status of validStatuses) {
            const mockRoom = {
              id: roomId,
              ownerId: 'user-123',
              status: RoomStatus.idle,
              inputText: 'Test input',
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            const mockUpdatedRoom = {
              ...mockRoom,
              status,
            };

            jest.spyOn(prismaService.room, 'findUnique').mockResolvedValue(mockRoom as any);
            jest.spyOn(prismaService.room, 'update').mockResolvedValue(mockUpdatedRoom as any);

            const result = await service.updateStatus(roomId, status);

            // Property: Status should always be one of the valid enum values
            expect(validStatuses).toContain(result.status);
          }
        }),
        { numRuns: 50 }
      );
    });
  });
});
