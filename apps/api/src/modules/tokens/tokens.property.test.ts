// Generated by Kiro - Property-Based Tests
// Feature: haunted-ai, Token Rewards Properties
// Validates: Requirements 9.1, 9.2, 9.5

import { Test, TestingModule } from '@nestjs/testing';
import * as fc from 'fast-check';

import { TokensService } from './tokens.service';
import { PrismaService } from '../../prisma/prisma.service';

describe('Token Rewards Property-Based Tests', () => {
  let service: TokensService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TokensService,
        {
          provide: PrismaService,
          useValue: {
            user: {
              findUnique: jest.fn(),
            },
            tokenTransaction: {
              findMany: jest.fn(),
              create: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<TokensService>(TokensService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Feature: haunted-ai, Property 30: Upload reward amount
  // Validates: Requirements 9.1
  describe('Property 30: Upload reward amount', () => {
    it('should reward exactly 10 tokens for any content upload', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            reason: fc.constantFrom('upload_story', 'upload_image', 'upload_code'),
          }),
          async ({ userId, reason }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock the reward transaction creation
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: BigInt(10),
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            // Execute reward
            const result = await service.rewardUser(userId, 10, reason);

            // Property: Upload rewards should always be exactly 10 tokens
            expect(result.amount).toBe(BigInt(10));
            expect(prismaService.tokenTransaction.create).toHaveBeenCalledWith({
              data: {
                userId,
                amount: BigInt(10),
                reason,
                txHash: undefined,
              },
            });
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record upload rewards with correct reason', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          async (userId) => {
            // Reset mocks
            jest.clearAllMocks();

            const reason = 'content_upload';
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: BigInt(10),
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, 10, reason);

            // Property: Upload reward transactions should have upload-related reason
            expect(result.reason).toContain('upload');
            expect(result.amount).toBe(BigInt(10));
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 31: View reward amount
  // Validates: Requirements 9.2
  describe('Property 31: View reward amount', () => {
    it('should reward exactly 1 token for any content view', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            reason: fc.constantFrom('view_story', 'view_image', 'view_code'),
          }),
          async ({ userId, reason }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock the reward transaction creation
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: BigInt(1),
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            // Execute reward
            const result = await service.rewardUser(userId, 1, reason);

            // Property: View rewards should always be exactly 1 token
            expect(result.amount).toBe(BigInt(1));
            expect(prismaService.tokenTransaction.create).toHaveBeenCalledWith({
              data: {
                userId,
                amount: BigInt(1),
                reason,
                txHash: undefined,
              },
            });
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record view rewards with correct reason', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          async (userId) => {
            // Reset mocks
            jest.clearAllMocks();

            const reason = 'content_view';
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: BigInt(1),
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, 1, reason);

            // Property: View reward transactions should have view-related reason
            expect(result.reason).toContain('view');
            expect(result.amount).toBe(BigInt(1));
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 34: Balance calculation correctness
  // Validates: Requirements 9.5
  describe('Property 34: Balance calculation correctness', () => {
    it('should calculate balance as sum of all transaction amounts', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userDid: fc.string({ minLength: 10, maxLength: 50 }),
            transactions: fc.array(
              fc.record({
                amount: fc.integer({ min: 1, max: 100 }),
                reason: fc.constantFrom('upload', 'view', 'referral', 'bonus'),
              }),
              { minLength: 1, maxLength: 20 }
            ),
          }),
          async ({ userDid, transactions }) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Mock transactions
            const mockTransactions = transactions.map((tx, index) => ({
              id: `tx-${index}`,
              userId,
              amount: BigInt(tx.amount),
              reason: tx.reason,
              txHash: null,
              createdAt: new Date(),
            }));

            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue(mockTransactions);

            // Get balance
            const result = await service.getBalance(userDid);

            // Calculate expected balance
            const expectedBalance = transactions.reduce((sum, tx) => sum + tx.amount, 0);

            // Property: Balance should equal sum of all transaction amounts
            expect(result.balance).toBe(expectedBalance);
            expect(result.transactionCount).toBe(transactions.length);
            expect(result.did).toBe(userDid);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle empty transaction history with zero balance', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.string({ minLength: 10, maxLength: 50 }),
          async (userDid) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Mock empty transactions
            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue([]);

            // Get balance
            const result = await service.getBalance(userDid);

            // Property: Empty transaction history should result in zero balance
            expect(result.balance).toBe(0);
            expect(result.transactionCount).toBe(0);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain balance consistency across multiple queries', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userDid: fc.string({ minLength: 10, maxLength: 50 }),
            transactions: fc.array(
              fc.integer({ min: 1, max: 50 }),
              { minLength: 5, maxLength: 15 }
            ),
          }),
          async ({ userDid, transactions }) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Mock transactions
            const mockTransactions = transactions.map((amount, index) => ({
              id: `tx-${index}`,
              userId,
              amount: BigInt(amount),
              reason: 'test',
              txHash: null,
              createdAt: new Date(),
            }));

            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue(mockTransactions);

            // Query balance multiple times
            const result1 = await service.getBalance(userDid);
            const result2 = await service.getBalance(userDid);

            // Property: Multiple queries should return consistent balance
            expect(result1.balance).toBe(result2.balance);
            expect(result1.transactionCount).toBe(result2.transactionCount);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should correctly sum positive and negative transactions', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userDid: fc.string({ minLength: 10, maxLength: 50 }),
            positiveAmounts: fc.array(
              fc.integer({ min: 1, max: 100 }),
              { minLength: 1, maxLength: 10 }
            ),
            negativeAmounts: fc.array(
              fc.integer({ min: -100, max: -1 }),
              { minLength: 0, maxLength: 5 }
            ),
          }),
          async ({ userDid, positiveAmounts, negativeAmounts }) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Combine positive and negative transactions
            const allAmounts = [...positiveAmounts, ...negativeAmounts];
            const mockTransactions = allAmounts.map((amount, index) => ({
              id: `tx-${index}`,
              userId,
              amount: BigInt(amount),
              reason: amount > 0 ? 'reward' : 'deduction',
              txHash: null,
              createdAt: new Date(),
            }));

            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue(mockTransactions);

            // Get balance
            const result = await service.getBalance(userDid);

            // Calculate expected balance
            const expectedBalance = allAmounts.reduce((sum, amount) => sum + amount, 0);

            // Property: Balance should correctly handle both positive and negative transactions
            expect(result.balance).toBe(expectedBalance);
            expect(result.transactionCount).toBe(allAmounts.length);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
