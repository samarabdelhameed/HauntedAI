// Generated by Kiro - Property-Based Tests
// Feature: haunted-ai, Token Rewards Properties
// Validates: Requirements 9.1, 9.2, 9.5

import { Test, TestingModule } from '@nestjs/testing';
import * as fc from 'fast-check';

import { TokensService } from './tokens.service';
import { PrismaService } from '../../prisma/prisma.service';
import { BlockchainService } from './blockchain.service';

describe('Token Rewards Property-Based Tests', () => {
  let service: TokensService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TokensService,
        {
          provide: PrismaService,
          useValue: {
            user: {
              findUnique: jest.fn(),
            },
            tokenTransaction: {
              findMany: jest.fn(),
              create: jest.fn(),
            },
          },
        },
        {
          provide: BlockchainService,
          useValue: {
            rewardUpload: jest.fn(),
            rewardView: jest.fn(),
            rewardReferral: jest.fn(),
            grantBadge: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<TokensService>(TokensService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Feature: haunted-ai, Property 30: Upload reward amount
  // Validates: Requirements 9.1
  describe('Property 30: Upload reward amount', () => {
    it('should reward exactly 10 tokens for any content upload', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            reason: fc.constantFrom('upload_story', 'upload_image', 'upload_code'),
          }),
          async ({ userId, reason }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock the reward transaction creation
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: 10,
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            // Execute reward
            const result = await service.rewardUser(userId, 10, reason);

            // Property: Upload rewards should always be exactly 10 tokens
            expect(result.amount).toBe(10);
            expect(prismaService.tokenTransaction.create).toHaveBeenCalledWith({
              data: {
                userId,
                amount: 10,
                reason,
                txHash: undefined,
              },
            });
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record upload rewards with correct reason', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          async (userId) => {
            // Reset mocks
            jest.clearAllMocks();

            const reason = 'content_upload';
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: 10,
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, 10, reason);

            // Property: Upload reward transactions should have upload-related reason
            expect(result.reason).toContain('upload');
            expect(result.amount).toBe(10);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 31: View reward amount
  // Validates: Requirements 9.2
  describe('Property 31: View reward amount', () => {
    it('should reward exactly 1 token for any content view', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            reason: fc.constantFrom('view_story', 'view_image', 'view_code'),
          }),
          async ({ userId, reason }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock the reward transaction creation
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: 1,
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            // Execute reward
            const result = await service.rewardUser(userId, 1, reason);

            // Property: View rewards should always be exactly 1 token
            expect(result.amount).toBe(1);
            expect(prismaService.tokenTransaction.create).toHaveBeenCalledWith({
              data: {
                userId,
                amount: 1,
                reason,
                txHash: undefined,
              },
            });
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record view rewards with correct reason', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          async (userId) => {
            // Reset mocks
            jest.clearAllMocks();

            const reason = 'content_view';
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: 1,
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, 1, reason);

            // Property: View reward transactions should have view-related reason
            expect(result.reason).toContain('view');
            expect(result.amount).toBe(1);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 32: Referral reward amount
  // Validates: Requirements 9.3
  describe('Property 32: Referral reward amount', () => {
    it('should reward exactly 50 tokens for any successful referral', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            referredUserId: fc.uuid(),
            reason: fc.constantFrom('referral', 'friend_referral', 'user_referral'),
          }),
          async ({ userId, referredUserId, reason }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock the reward transaction creation
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: 50,
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            // Execute reward
            const result = await service.rewardUser(userId, 50, reason);

            // Property: Referral rewards should always be exactly 50 tokens
            expect(result.amount).toBe(50);
            expect(prismaService.tokenTransaction.create).toHaveBeenCalledWith({
              data: {
                userId,
                amount: 50,
                reason,
                txHash: undefined,
              },
            });
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record referral rewards with correct reason', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.uuid(),
          async (userId) => {
            // Reset mocks
            jest.clearAllMocks();

            const reason = 'friend_referral';
            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount: 50,
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, 50, reason);

            // Property: Referral reward transactions should have referral-related reason
            expect(result.reason).toContain('referral');
            expect(result.amount).toBe(50);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain correct referral reward amount across multiple referrals', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            referralCount: fc.integer({ min: 1, max: 10 }),
          }),
          async ({ userId, referralCount }) => {
            // Reset mocks
            jest.clearAllMocks();

            const mockTransactions = [];
            for (let i = 0; i < referralCount; i++) {
              const mockTransaction = {
                id: `tx-${i}`,
                userId,
                amount: 50,
                reason: `referral_${i}`,
                txHash: null,
                createdAt: new Date(),
              };
              mockTransactions.push(mockTransaction);

              jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValueOnce(mockTransaction);

              const result = await service.rewardUser(userId, 50, `referral_${i}`);

              // Property: Each referral should always reward exactly 50 tokens
              expect(result.amount).toBe(50);
            }

            // Verify all referrals were processed
            expect(prismaService.tokenTransaction.create).toHaveBeenCalledTimes(referralCount);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 33: Transaction logging
  // Validates: Requirements 9.4
  describe('Property 33: Transaction logging', () => {
    it('should record transaction with valid Polygon tx_hash pattern', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            amount: fc.integer({ min: 1, max: 100 }),
            reason: fc.constantFrom('upload', 'view', 'referral'),
          }),
          fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }),
          async ({ userId, amount, reason }, hexArray) => {
            const txHash = `0x${hexArray.join('')}`;
            // Reset mocks
            jest.clearAllMocks();

            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount,
              reason,
              txHash,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            // Execute reward with tx_hash
            const result = await service.rewardUser(userId, amount, reason, txHash);

            // Property: Transaction should be logged with valid Polygon tx_hash
            expect(result.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);
            expect(result.userId).toBe(userId);
            expect(result.amount).toBe(amount);
            expect(result.reason).toBe(reason);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record transaction with all required fields', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            amount: fc.integer({ min: 1, max: 100 }),
            reason: fc.string({ minLength: 3, maxLength: 50 }),
          }),
          async ({ userId, amount, reason }) => {
            // Reset mocks
            jest.clearAllMocks();

            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount,
              reason,
              txHash: null,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, amount, reason);

            // Property: Every transaction must have userId, amount, reason, and createdAt
            expect(result.userId).toBe(userId);
            expect(result.amount).toBe(amount);
            expect(result.reason).toBe(reason);
            expect(result.createdAt).toBeInstanceOf(Date);
            expect(result.id).toBeDefined();
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain transaction order by creation time', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            transactionCount: fc.integer({ min: 2, max: 10 }),
          }),
          async ({ userId, transactionCount }) => {
            // Reset mocks
            jest.clearAllMocks();

            const mockTransactions = [];
            const baseTime = Date.now();

            // Create transactions with incrementing timestamps
            for (let i = 0; i < transactionCount; i++) {
              const mockTransaction = {
                id: `tx-${i}`,
                userId,
                amount: 10,
                reason: `transaction_${i}`,
                txHash: null,
                createdAt: new Date(baseTime + i * 1000),
              };
              mockTransactions.push(mockTransaction);
            }

            // Mock findMany to return transactions in order
            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue({
              id: userId,
              did: `did:key:${userId}`,
              username: 'testuser',
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            });

            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue(mockTransactions);

            const result = await service.getTransactions(`did:key:${userId}`);

            // Property: Transactions should maintain chronological order
            for (let i = 1; i < result.length; i++) {
              const prevTime = result[i - 1].createdAt.getTime();
              const currTime = result[i].createdAt.getTime();
              expect(currTime).toBeGreaterThanOrEqual(prevTime);
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record transaction with optional blockchain tx_hash', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            amount: fc.integer({ min: 1, max: 100 }),
            reason: fc.string({ minLength: 3, maxLength: 50 }),
            includeTxHash: fc.boolean(),
          }),
          async ({ userId, amount, reason, includeTxHash }) => {
            // Reset mocks
            jest.clearAllMocks();

            const txHash = includeTxHash 
              ? `0x${fc.sample(fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }), 1)[0].join('')}`
              : null;

            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount,
              reason,
              txHash,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, amount, reason, txHash || undefined);

            // Property: Transaction can be recorded with or without blockchain tx_hash
            if (includeTxHash) {
              expect(result.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);
            } else {
              expect(result.txHash).toBeNull();
            }
            expect(result.userId).toBe(userId);
            expect(result.amount).toBe(amount);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should persist transaction data correctly', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            amount: fc.integer({ min: 1, max: 1000 }),
            reason: fc.constantFrom('upload', 'view', 'referral', 'bonus', 'reward'),
          }),
          fc.option(fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }), { nil: null }),
          async ({ userId, amount, reason }, hexOption) => {
            const txHash = hexOption ? `0x${hexOption.join('')}` : null;
            // Reset mocks
            jest.clearAllMocks();

            const mockTransaction = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              amount,
              reason,
              txHash,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.tokenTransaction, 'create').mockResolvedValue(mockTransaction);

            const result = await service.rewardUser(userId, amount, reason, txHash || undefined);

            // Property: All transaction data should be persisted correctly
            expect(prismaService.tokenTransaction.create).toHaveBeenCalledWith({
              data: {
                userId,
                amount,
                reason,
                txHash: txHash || undefined,
              },
            });

            expect(result.userId).toBe(userId);
            expect(result.amount).toBe(amount);
            expect(result.reason).toBe(reason);
            expect(result.txHash).toBe(txHash);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 34: Balance calculation correctness
  // Validates: Requirements 9.5
  describe('Property 34: Balance calculation correctness', () => {
    it('should calculate balance as sum of all transaction amounts', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userDid: fc.string({ minLength: 10, maxLength: 50 }),
            transactions: fc.array(
              fc.record({
                amount: fc.integer({ min: 1, max: 100 }),
                reason: fc.constantFrom('upload', 'view', 'referral', 'bonus'),
              }),
              { minLength: 1, maxLength: 20 }
            ),
          }),
          async ({ userDid, transactions }) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Mock transactions
            const mockTransactions = transactions.map((tx, index) => ({
              id: `tx-${index}`,
              userId,
              amount: tx.amount,
              reason: tx.reason,
              txHash: null,
              createdAt: new Date(),
            }));

            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue(mockTransactions);

            // Get balance
            const result = await service.getBalance(userDid);

            // Calculate expected balance
            const expectedBalance = transactions.reduce((sum, tx) => sum + tx.amount, 0);

            // Property: Balance should equal sum of all transaction amounts
            expect(result.balance).toBe(expectedBalance);
            expect(result.transactionCount).toBe(transactions.length);
            expect(result.did).toBe(userDid);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle empty transaction history with zero balance', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.string({ minLength: 10, maxLength: 50 }),
          async (userDid) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Mock empty transactions
            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue([]);

            // Get balance
            const result = await service.getBalance(userDid);

            // Property: Empty transaction history should result in zero balance
            expect(result.balance).toBe(0);
            expect(result.transactionCount).toBe(0);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain balance consistency across multiple queries', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userDid: fc.string({ minLength: 10, maxLength: 50 }),
            transactions: fc.array(
              fc.integer({ min: 1, max: 50 }),
              { minLength: 5, maxLength: 15 }
            ),
          }),
          async ({ userDid, transactions }) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Mock transactions
            const mockTransactions = transactions.map((amount, index) => ({
              id: `tx-${index}`,
              userId,
              amount: amount,
              reason: 'test',
              txHash: null,
              createdAt: new Date(),
            }));

            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue(mockTransactions);

            // Query balance multiple times
            const result1 = await service.getBalance(userDid);
            const result2 = await service.getBalance(userDid);

            // Property: Multiple queries should return consistent balance
            expect(result1.balance).toBe(result2.balance);
            expect(result1.transactionCount).toBe(result2.transactionCount);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should correctly sum positive and negative transactions', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userDid: fc.string({ minLength: 10, maxLength: 50 }),
            positiveAmounts: fc.array(
              fc.integer({ min: 1, max: 100 }),
              { minLength: 1, maxLength: 10 }
            ),
            negativeAmounts: fc.array(
              fc.integer({ min: -100, max: -1 }),
              { minLength: 0, maxLength: 5 }
            ),
          }),
          async ({ userDid, positiveAmounts, negativeAmounts }) => {
            // Reset mocks
            jest.clearAllMocks();

            const userId = fc.sample(fc.uuid(), 1)[0];
            const username = `user_${userDid.slice(0, 8)}`;

            // Mock user lookup
            const mockUser = {
              id: userId,
              did: userDid,
              username,
              walletAddress: null,
              createdAt: new Date(),
              updatedAt: new Date(),
            };

            jest.spyOn(prismaService.user, 'findUnique').mockResolvedValue(mockUser);

            // Combine positive and negative transactions
            const allAmounts = [...positiveAmounts, ...negativeAmounts];
            const mockTransactions = allAmounts.map((amount, index) => ({
              id: `tx-${index}`,
              userId,
              amount: amount,
              reason: amount > 0 ? 'reward' : 'deduction',
              txHash: null,
              createdAt: new Date(),
            }));

            jest.spyOn(prismaService.tokenTransaction, 'findMany').mockResolvedValue(mockTransactions);

            // Get balance
            const result = await service.getBalance(userDid);

            // Calculate expected balance
            const expectedBalance = allAmounts.reduce((sum, amount) => sum + amount, 0);

            // Property: Balance should correctly handle both positive and negative transactions
            expect(result.balance).toBe(expectedBalance);
            expect(result.transactionCount).toBe(allAmounts.length);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
