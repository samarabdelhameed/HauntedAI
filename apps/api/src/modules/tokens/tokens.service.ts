// Generated by Kiro
import { Injectable, NotFoundException, Logger } from '@nestjs/common';

import { PrismaService } from '../../prisma/prisma.service';
import { BlockchainService } from './blockchain.service';

@Injectable()
export class TokensService {
  private readonly logger = new Logger(TokensService.name);

  constructor(
    private prisma: PrismaService,
    private blockchainService: BlockchainService
  ) {}

  /**
   * Get user token balance
   * Requirements: 9.5
   */
  async getBalance(userDid: string) {
    const user = await this.prisma.user.findUnique({
      where: { did: userDid },
    });

    if (!user) {
      throw new NotFoundException(`User with DID ${userDid} not found`);
    }

    const transactions = await this.prisma.tokenTransaction.findMany({
      where: { userId: user.id },
    });

    const balance = transactions.reduce((sum, tx) => sum + Number(tx.amount), 0);

    return {
      userId: user.id,
      did: user.did,
      username: user.username,
      balance,
      transactionCount: transactions.length,
    };
  }

  /**
   * Get user transaction history
   * Requirements: 9.4
   */
  async getTransactions(userDid: string, limit = 50, offset = 0) {
    const user = await this.prisma.user.findUnique({
      where: { did: userDid },
    });

    if (!user) {
      throw new NotFoundException(`User with DID ${userDid} not found`);
    }

    const transactions = await this.prisma.tokenTransaction.findMany({
      where: { userId: user.id },
      orderBy: { createdAt: 'desc' },
      take: limit,
      skip: offset,
    });

    return transactions;
  }

  /**
   * Reward user with tokens (internal use)
   * Requirements: 9.1, 9.2, 9.3
   */
  async rewardUser(userId: string, amount: number, reason: string, txHash?: string) {
    const transaction = await this.prisma.tokenTransaction.create({
      data: {
        userId,
        amount,
        reason,
        txHash,
      },
    });

    return transaction;
  }

  /**
   * Reward user for uploading content
   * Calls blockchain and records transaction in database
   * Requirements: 9.1, 9.4
   */
  async rewardUpload(userId: string) {
    try {
      // Get user wallet address
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException(`User with ID ${userId} not found`);
      }

      if (!user.walletAddress) {
        throw new Error(`User ${userId} does not have a wallet address`);
      }

      this.logger.log(`Rewarding upload for user ${userId} (${user.walletAddress})`);

      // Call blockchain to mint tokens
      const { txHash, amount } = await this.blockchainService.rewardUpload(user.walletAddress);

      // Record transaction in database
      const transaction = await this.prisma.tokenTransaction.create({
        data: {
          userId,
          amount: parseFloat(amount),
          reason: 'Upload Reward',
          txHash,
        },
      });

      this.logger.log(`Upload reward recorded: ${txHash}`);

      return transaction;
    } catch (error) {
      this.logger.error(`Failed to reward upload for user ${userId}`, error);
      throw error;
    }
  }

  /**
   * Reward user for viewing content
   * Calls blockchain and records transaction in database
   * Requirements: 9.2, 9.4
   */
  async rewardView(userId: string) {
    try {
      // Get user wallet address
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException(`User with ID ${userId} not found`);
      }

      if (!user.walletAddress) {
        throw new Error(`User ${userId} does not have a wallet address`);
      }

      this.logger.log(`Rewarding view for user ${userId} (${user.walletAddress})`);

      // Call blockchain to mint tokens
      const { txHash, amount } = await this.blockchainService.rewardView(user.walletAddress);

      // Record transaction in database
      const transaction = await this.prisma.tokenTransaction.create({
        data: {
          userId,
          amount: parseFloat(amount),
          reason: 'View Reward',
          txHash,
        },
      });

      this.logger.log(`View reward recorded: ${txHash}`);

      return transaction;
    } catch (error) {
      this.logger.error(`Failed to reward view for user ${userId}`, error);
      throw error;
    }
  }

  /**
   * Reward user for successful referral
   * Calls blockchain and records transaction in database
   * Requirements: 9.3, 9.4
   */
  async rewardReferral(userId: string) {
    try {
      // Get user wallet address
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException(`User with ID ${userId} not found`);
      }

      if (!user.walletAddress) {
        throw new Error(`User ${userId} does not have a wallet address`);
      }

      this.logger.log(`Rewarding referral for user ${userId} (${user.walletAddress})`);

      // Call blockchain to mint tokens
      const { txHash, amount } = await this.blockchainService.rewardReferral(user.walletAddress);

      // Record transaction in database
      const transaction = await this.prisma.tokenTransaction.create({
        data: {
          userId,
          amount: parseFloat(amount),
          reason: 'Referral Reward',
          txHash,
        },
      });

      this.logger.log(`Referral reward recorded: ${txHash}`);

      return transaction;
    } catch (error) {
      this.logger.error(`Failed to reward referral for user ${userId}`, error);
      throw error;
    }
  }

  /**
   * Check user achievements and grant badges
   * Requirements: 16.1, 16.2, 16.3
   */
  async checkAndGrantBadges(userId: string) {
    try {
      // Get user wallet address
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException(`User with ID ${userId} not found`);
      }

      if (!user.walletAddress) {
        this.logger.warn(`User ${userId} does not have a wallet address, skipping badge check`);
        return [];
      }

      // Get user stats from blockchain
      const stats = await this.blockchainService.getUserStats(user.walletAddress);

      const grantedBadges = [];

      // Check for "Ghost Novice" badge (1 room completed)
      if (stats.roomCount >= 1) {
        const hasGhostNovice = await this.blockchainService.hasBadgeType(user.walletAddress, 'Ghost Novice');
        if (!hasGhostNovice) {
          const badge = await this.grantBadge(userId, 'Ghost Novice');
          grantedBadges.push(badge);
        }
      }

      // Check for "Haunted Creator" badge (10 rooms completed)
      if (stats.roomCount >= 10) {
        const hasHauntedCreator = await this.blockchainService.hasBadgeType(user.walletAddress, 'Haunted Creator');
        if (!hasHauntedCreator) {
          const badge = await this.grantBadge(userId, 'Haunted Creator');
          grantedBadges.push(badge);
        }
      }

      // Check for "Haunted Master" badge (1000 HHCW earned)
      if (parseFloat(stats.totalEarned) >= 1000) {
        const hasHauntedMaster = await this.blockchainService.hasBadgeType(user.walletAddress, 'Haunted Master');
        if (!hasHauntedMaster) {
          const badge = await this.grantBadge(userId, 'Haunted Master');
          grantedBadges.push(badge);
        }
      }

      // Check for "Spooky Legend" badge (100 rooms completed)
      if (stats.roomCount >= 100) {
        const hasSpookyLegend = await this.blockchainService.hasBadgeType(user.walletAddress, 'Spooky Legend');
        if (!hasSpookyLegend) {
          const badge = await this.grantBadge(userId, 'Spooky Legend');
          grantedBadges.push(badge);
        }
      }

      return grantedBadges;
    } catch (error) {
      this.logger.error(`Failed to check and grant badges for user ${userId}`, error);
      throw error;
    }
  }

  /**
   * Grant a badge to a user
   * Requirements: 16.1, 16.2, 16.3
   */
  async grantBadge(userId: string, badgeType: string) {
    try {
      // Get user wallet address
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException(`User with ID ${userId} not found`);
      }

      if (!user.walletAddress) {
        throw new Error(`User ${userId} does not have a wallet address`);
      }

      this.logger.log(`Granting badge "${badgeType}" to user ${userId} (${user.walletAddress})`);

      // Call blockchain to mint badge
      const { txHash, tokenId } = await this.blockchainService.grantBadge(user.walletAddress, badgeType);

      // Record badge in database
      const badge = await this.prisma.badge.create({
        data: {
          userId,
          tokenId: parseInt(tokenId),
          badgeType,
          txHash,
        },
      });

      this.logger.log(`Badge granted successfully: ${badgeType} (tokenId: ${tokenId}, txHash: ${txHash})`);

      return badge;
    } catch (error) {
      this.logger.error(`Failed to grant badge "${badgeType}" to user ${userId}`, error);
      throw error;
    }
  }

  /**
   * Get all badges owned by a user
   * Requirements: 16.4
   */
  async getUserBadges(userId: string) {
    try {
      // Get user wallet address
      const user = await this.prisma.user.findUnique({
        where: { id: userId },
      });

      if (!user) {
        throw new NotFoundException(`User with ID ${userId} not found`);
      }

      if (!user.walletAddress) {
        return [];
      }

      // Get badges from blockchain
      const blockchainBadges = await this.blockchainService.getUserBadges(user.walletAddress);

      // Get badges from database for additional metadata
      const dbBadges = await this.prisma.badge.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
      });

      // Merge blockchain and database data
      const badges = blockchainBadges.map((blockchainBadge) => {
        const dbBadge = dbBadges.find((b) => b.tokenId === parseInt(blockchainBadge.tokenId));
        return {
          tokenId: blockchainBadge.tokenId,
          badgeType: blockchainBadge.badgeType,
          txHash: dbBadge?.txHash,
          createdAt: dbBadge?.createdAt,
        };
      });

      return badges;
    } catch (error) {
      this.logger.error(`Failed to get badges for user ${userId}`, error);
      throw error;
    }
  }

  /**
   * Get badge metadata
   * Requirements: 16.5
   */
  async getBadgeMetadata(tokenId: string) {
    try {
      const badge = await this.prisma.badge.findFirst({
        where: { tokenId: parseInt(tokenId) },
        include: {
          user: {
            select: {
              username: true,
              walletAddress: true,
            },
          },
        },
      });

      if (!badge) {
        throw new NotFoundException(`Badge with tokenId ${tokenId} not found`);
      }

      return {
        tokenId: badge.tokenId,
        badgeType: badge.badgeType,
        owner: badge.user.username,
        walletAddress: badge.user.walletAddress,
        txHash: badge.txHash,
        createdAt: badge.createdAt,
      };
    } catch (error) {
      this.logger.error(`Failed to get badge metadata for tokenId ${tokenId}`, error);
      throw error;
    }
  }
}
