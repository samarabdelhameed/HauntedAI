// Generated by Kiro - Property-Based Tests
// Feature: haunted-ai, NFT Badges Properties
// Validates: Requirements 16.1, 16.2, 16.3

import { Test, TestingModule } from '@nestjs/testing';
import * as fc from 'fast-check';

import { TokensService } from './tokens.service';
import { PrismaService } from '../../prisma/prisma.service';

describe('NFT Badges Property-Based Tests', () => {
  let service: TokensService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TokensService,
        {
          provide: PrismaService,
          useValue: {
            user: {
              findUnique: jest.fn(),
            },
            badge: {
              findMany: jest.fn(),
              create: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<TokensService>(TokensService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Feature: haunted-ai, Property 59: Achievement badge minting
  // Validates: Requirements 16.1
  describe('Property 59: Achievement badge minting', () => {
    it('should mint Ghost Novice badge when user completes first room', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            walletAddress: fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 40, maxLength: 40 }),
            roomCount: fc.constant(1),
          }),
          async ({ userId, walletAddress, roomCount }) => {
            // Reset mocks
            jest.clearAllMocks();

            const walletAddr = `0x${walletAddress.join('')}`;
            const badgeType = 'Ghost Novice';

            // Mock badge creation
            const mockBadge = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              tokenId: 1,
              badgeType,
              txHash: `0x${fc.sample(fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }), 1)[0].join('')}`,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.badge, 'create').mockResolvedValue(mockBadge);

            // Property: First room completion should trigger Ghost Novice badge
            if (roomCount === 1) {
              expect(badgeType).toBe('Ghost Novice');
              expect(mockBadge.badgeType).toBe('Ghost Novice');
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should mint Haunted Creator badge when user completes 10 rooms', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            roomCount: fc.constant(10),
          }),
          async ({ userId, roomCount }) => {
            // Reset mocks
            jest.clearAllMocks();

            const badgeType = 'Haunted Creator';

            // Mock badge creation
            const mockBadge = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              tokenId: 2,
              badgeType,
              txHash: `0x${fc.sample(fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }), 1)[0].join('')}`,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.badge, 'create').mockResolvedValue(mockBadge);

            // Property: 10 rooms completion should trigger Haunted Creator badge
            if (roomCount === 10) {
              expect(badgeType).toBe('Haunted Creator');
              expect(mockBadge.badgeType).toBe('Haunted Creator');
            }
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 60: Milestone badge minting
  // Validates: Requirements 16.2
  describe('Property 60: Milestone badge minting', () => {
    it('should mint Haunted Master badge when user earns 1000 HHCW', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            totalEarned: fc.constant(1000),
          }),
          async ({ userId, totalEarned }) => {
            // Reset mocks
            jest.clearAllMocks();

            const badgeType = 'Haunted Master';

            // Mock badge creation
            const mockBadge = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              tokenId: 3,
              badgeType,
              txHash: `0x${fc.sample(fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }), 1)[0].join('')}`,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.badge, 'create').mockResolvedValue(mockBadge);

            // Property: 1000 HHCW earned should trigger Haunted Master badge
            if (totalEarned >= 1000) {
              expect(badgeType).toBe('Haunted Master');
              expect(mockBadge.badgeType).toBe('Haunted Master');
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should mint Spooky Legend badge when user completes 100 rooms', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            roomCount: fc.constant(100),
          }),
          async ({ userId, roomCount }) => {
            // Reset mocks
            jest.clearAllMocks();

            const badgeType = 'Spooky Legend';

            // Mock badge creation
            const mockBadge = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              tokenId: 4,
              badgeType,
              txHash: `0x${fc.sample(fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }), 1)[0].join('')}`,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.badge, 'create').mockResolvedValue(mockBadge);

            // Property: 100 rooms completion should trigger Spooky Legend badge
            if (roomCount >= 100) {
              expect(badgeType).toBe('Spooky Legend');
              expect(mockBadge.badgeType).toBe('Spooky Legend');
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain correct badge eligibility thresholds', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomCount: fc.integer({ min: 0, max: 150 }),
            totalEarned: fc.integer({ min: 0, max: 2000 }),
          }),
          async ({ roomCount, totalEarned }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Property: Badge eligibility should follow correct thresholds
            const eligibleForNovice = roomCount >= 1;
            const eligibleForCreator = roomCount >= 10;
            const eligibleForMaster = totalEarned >= 1000;
            const eligibleForLegend = roomCount >= 100;

            // Verify threshold logic
            if (roomCount === 0) {
              expect(eligibleForNovice).toBe(false);
            }
            if (roomCount >= 1 && roomCount < 10) {
              expect(eligibleForNovice).toBe(true);
              expect(eligibleForCreator).toBe(false);
            }
            if (roomCount >= 10 && roomCount < 100) {
              expect(eligibleForCreator).toBe(true);
              expect(eligibleForLegend).toBe(false);
            }
            if (roomCount >= 100) {
              expect(eligibleForLegend).toBe(true);
            }
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 61: Badge transaction recording
  // Validates: Requirements 16.3
  describe('Property 61: Badge transaction recording', () => {
    it('should record badge with valid Polygon tx_hash', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            badgeType: fc.constantFrom('Ghost Novice', 'Haunted Creator', 'Haunted Master', 'Spooky Legend'),
            tokenId: fc.integer({ min: 1, max: 1000 }),
          }),
          fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }),
          async ({ userId, badgeType, tokenId }, hexArray) => {
            // Reset mocks
            jest.clearAllMocks();

            const txHash = `0x${hexArray.join('')}`;

            // Mock badge creation
            const mockBadge = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              tokenId,
              badgeType,
              txHash,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.badge, 'create').mockResolvedValue(mockBadge);

            // Property: Badge should be recorded with valid Polygon tx_hash
            expect(mockBadge.txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);
            expect(mockBadge.userId).toBe(userId);
            expect(mockBadge.badgeType).toBe(badgeType);
            expect(mockBadge.tokenId).toBe(tokenId);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should record badge with all required fields', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            badgeType: fc.string({ minLength: 5, maxLength: 50 }),
            tokenId: fc.integer({ min: 1, max: 10000 }),
          }),
          async ({ userId, badgeType, tokenId }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock badge creation
            const mockBadge = {
              id: fc.sample(fc.uuid(), 1)[0],
              userId,
              tokenId,
              badgeType,
              txHash: `0x${fc.sample(fc.array(fc.constantFrom('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'), { minLength: 64, maxLength: 64 }), 1)[0].join('')}`,
              createdAt: new Date(),
            };

            jest.spyOn(prismaService.badge, 'create').mockResolvedValue(mockBadge);

            // Property: Every badge must have userId, tokenId, badgeType, txHash, and createdAt
            expect(mockBadge.userId).toBe(userId);
            expect(mockBadge.tokenId).toBe(tokenId);
            expect(mockBadge.badgeType).toBe(badgeType);
            expect(mockBadge.txHash).toBeDefined();
            expect(mockBadge.createdAt).toBeInstanceOf(Date);
            expect(mockBadge.id).toBeDefined();
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should prevent duplicate badge types for same user', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            badgeType: fc.constantFrom('Ghost Novice', 'Haunted Creator'),
          }),
          async ({ userId, badgeType }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock existing badges
            const existingBadges = [
              {
                id: fc.sample(fc.uuid(), 1)[0],
                userId,
                tokenId: 1,
                badgeType,
                txHash: `0x${'1'.repeat(64)}`,
                createdAt: new Date(),
              },
            ];

            jest.spyOn(prismaService.badge, 'findMany').mockResolvedValue(existingBadges);

            const badges = await prismaService.badge.findMany({ where: { userId } });

            // Property: User should not have duplicate badge types
            const badgeTypes = badges.map(b => b.badgeType);
            const uniqueBadgeTypes = [...new Set(badgeTypes)];
            expect(badgeTypes.length).toBe(uniqueBadgeTypes.length);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain badge order by creation time', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            userId: fc.uuid(),
            badgeCount: fc.integer({ min: 2, max: 5 }),
          }),
          async ({ userId, badgeCount }) => {
            // Reset mocks
            jest.clearAllMocks();

            const mockBadges = [];
            const baseTime = Date.now();

            // Create badges with incrementing timestamps
            for (let i = 0; i < badgeCount; i++) {
              const mockBadge = {
                id: `badge-${i}`,
                userId,
                tokenId: i + 1,
                badgeType: `Badge ${i}`,
                txHash: `0x${'1'.repeat(64)}`,
                createdAt: new Date(baseTime + i * 1000),
              };
              mockBadges.push(mockBadge);
            }

            jest.spyOn(prismaService.badge, 'findMany').mockResolvedValue(mockBadges);

            const badges = await prismaService.badge.findMany({ where: { userId } });

            // Property: Badges should maintain chronological order
            for (let i = 1; i < badges.length; i++) {
              const prevTime = badges[i - 1].createdAt.getTime();
              const currTime = badges[i].createdAt.getTime();
              expect(currTime).toBeGreaterThanOrEqual(prevTime);
            }
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
