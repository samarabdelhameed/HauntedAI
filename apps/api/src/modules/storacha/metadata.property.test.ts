// Generated by Kiro
// Managed by Kiro - CID Metadata Property-Based Tests

import { Test, TestingModule } from '@nestjs/testing';
import fc from 'fast-check';
import { PrismaService } from '../../prisma/prisma.service';

// Mock the @web3-storage/w3up-client module
jest.mock('@web3-storage/w3up-client', () => ({
  create: jest.fn().mockResolvedValue({
    uploadFile: jest.fn(),
  }),
}));

import { StorachaService } from './storacha.service';
import { MetadataService } from './metadata.service';

/**
 * Property-Based Tests for CID Metadata Storage
 * 
 * Tests the following property:
 * - Property 24: CID metadata persistence
 * 
 * Validates: Requirements 7.3
 */
describe('CID Metadata Service - Property Tests', () => {
  let metadataService: MetadataService;
  let storachaService: StorachaService;
  let prismaService: PrismaService;

  // Mock data
  const mockRoomId = 'test-room-id';
  const mockUserId = 'test-user-id';

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MetadataService,
        StorachaService,
        {
          provide: PrismaService,
          useValue: {
            asset: {
              create: jest.fn(),
              findFirst: jest.fn(),
              findMany: jest.fn(),
            },
            room: {
              findUnique: jest.fn(),
            },
            user: {
              findUnique: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    metadataService = module.get<MetadataService>(MetadataService);
    storachaService = module.get<StorachaService>(StorachaService);
    prismaService = module.get<PrismaService>(PrismaService);

    // Mock Storacha client
    jest.spyOn(storachaService as any, 'initialize').mockResolvedValue(undefined);
    (storachaService as any).client = {
      uploadFile: jest.fn().mockImplementation(async (file: File) => {
        const hash = Buffer.from(file.name)
          .toString('hex')
          .toLowerCase()
          .replace(/[^a-z2-7]/g, '2')
          .substring(0, 55);
        return { toString: () => `bafy${hash.padEnd(55, '2')}` };
      }),
    };
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Feature: haunted-ai, Property 24: CID metadata persistence
  // Validates: Requirements 7.3
  describe('Property 24: CID metadata persistence', () => {
    it('should persist complete CID metadata to database', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            agentType: fc.constantFrom('story', 'asset', 'code', 'deploy'),
            cid: fc.string({ minLength: 59, maxLength: 59 }).map(s => 
              'bafy' + s.toLowerCase().replace(/[^a-z2-7]/g, '2').substring(0, 55)
            ),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html', 'application/json'),
            fileSize: fc.integer({ min: 1, max: 1000000 }),
            metadata: fc.record({
              description: fc.string({ minLength: 1, maxLength: 100 }),
              version: fc.integer({ min: 1, max: 10 }),
            }),
          }),
          async ({ agentType, cid, fileType, fileSize, metadata }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock database response
            const mockAsset = {
              id: 'test-asset-id',
              roomId: mockRoomId,
              agentType,
              cid,
              fileType,
              fileSize,
              metadata: JSON.stringify(metadata),
              createdAt: new Date(),
            };

            (prismaService.asset.create as jest.Mock).mockResolvedValue(mockAsset);

            // Save CID metadata
            const result = await metadataService.saveCIDMetadata(
              mockRoomId,
              agentType as any,
              cid,
              fileType,
              fileSize,
              metadata
            );

            // Verify database was called with correct data
            expect(prismaService.asset.create).toHaveBeenCalledWith({
              data: {
                roomId: mockRoomId,
                agentType,
                cid,
                fileType,
                fileSize,
                metadata: JSON.stringify(metadata),
              },
            });

            // Verify returned asset has all required fields
            expect(result.id).toBeDefined();
            expect(result.cid).toBe(cid);
            expect(result.fileType).toBe(fileType);
            expect(result.fileSize).toBe(fileSize);
            expect(result.agentType).toBe(agentType);
            expect(result.createdAt).toBeInstanceOf(Date);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should retrieve CID metadata with all fields intact', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            cid: fc.string({ minLength: 59, maxLength: 59 }).map(s => 
              'bafy' + s.toLowerCase().replace(/[^a-z2-7]/g, '2').substring(0, 55)
            ),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html'),
            fileSize: fc.integer({ min: 1, max: 1000000 }),
            metadata: fc.record({
              key: fc.string({ minLength: 1, maxLength: 50 }),
              value: fc.integer({ min: 0, max: 100 }),
            }),
          }),
          async ({ cid, fileType, fileSize, metadata }) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock database response
            const mockAsset = {
              id: 'test-asset-id',
              roomId: mockRoomId,
              agentType: 'story',
              cid,
              fileType,
              fileSize,
              metadata: JSON.stringify(metadata),
              createdAt: new Date(),
              room: {
                id: mockRoomId,
                ownerId: mockUserId,
                status: 'done',
                inputText: 'test',
                createdAt: new Date(),
                updatedAt: new Date(),
                owner: {
                  id: mockUserId,
                  username: 'testuser',
                  did: 'did:test:123',
                },
              },
            };

            (prismaService.asset.findFirst as jest.Mock).mockResolvedValue(mockAsset);

            // Retrieve CID metadata
            const result = await metadataService.getCIDMetadata(cid);

            // Verify all fields are present and correct
            expect(result.cid).toBe(cid);
            expect(result.fileType).toBe(fileType);
            expect(result.fileSize).toBe(fileSize);
            expect(result.metadata).toEqual(metadata);
            expect(result.createdAt).toBeInstanceOf(Date);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Additional test: CID validation
  describe('CID Validation', () => {
    it('should reject invalid CID format when saving metadata', async () => {
      const invalidCIDs = [
        'invalid',
        'bafy', // too short
        'Qm' + 'a'.repeat(44), // CID v0
        '',
      ];

      for (const invalidCID of invalidCIDs) {
        await expect(
          metadataService.saveCIDMetadata(
            mockRoomId,
            'story',
            invalidCID,
            'text/plain',
            100
          )
        ).rejects.toThrow('Invalid CID format');
      }
    });

    it('should accept valid CID format', async () => {
      const validCID = 'bafy' + '2'.repeat(55);

      const mockAsset = {
        id: 'test-asset-id',
        roomId: mockRoomId,
        agentType: 'story',
        cid: validCID,
        fileType: 'text/plain',
        fileSize: 100,
        metadata: null,
        createdAt: new Date(),
      };

      (prismaService.asset.create as jest.Mock).mockResolvedValue(mockAsset);

      const result = await metadataService.saveCIDMetadata(
        mockRoomId,
        'story',
        validCID,
        'text/plain',
        100
      );

      expect(result.cid).toBe(validCID);
    });
  });

  // Additional test: Upload and save metadata in one operation
  describe('Upload and Save Metadata', () => {
    it('should upload file and save metadata atomically', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            content: fc.string({ minLength: 10, maxLength: 1000 }),
            filename: fc.string({ minLength: 1, maxLength: 50 }).map(s => 
              s.replace(/[^a-zA-Z0-9]/g, '') + '.txt'
            ),
            agentType: fc.constantFrom('story', 'asset', 'code', 'deploy'),
            fileType: fc.constantFrom('text/plain', 'image/png', 'text/html'),
          }),
          async ({ content, filename, agentType, fileType }) => {
            // Reset mocks
            jest.clearAllMocks();

            const buffer = Buffer.from(content);
            const mockCID = 'bafy' + '2'.repeat(55);

            // Mock upload
            (storachaService as any).client.uploadFile = jest.fn().mockResolvedValue({
              toString: () => mockCID,
            });

            // Mock database save
            const mockAsset = {
              id: 'test-asset-id',
              roomId: mockRoomId,
              agentType,
              cid: mockCID,
              fileType,
              fileSize: buffer.length,
              metadata: null,
              createdAt: new Date(),
            };

            (prismaService.asset.create as jest.Mock).mockResolvedValue(mockAsset);

            // Upload and save metadata
            const result = await metadataService.uploadAndSaveMetadata(
              mockRoomId,
              agentType as any,
              buffer,
              filename,
              fileType
            );

            // Verify both operations completed
            expect(result.cid).toBe(mockCID);
            expect(result.asset.cid).toBe(mockCID);
            expect(result.asset.fileSize).toBe(buffer.length);
            expect(result.asset.fileType).toBe(fileType);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
