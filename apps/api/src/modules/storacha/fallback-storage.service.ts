// Generated by Kiro
// Managed by Kiro - Fallback Storage Service

import { Injectable, Logger } from '@nestjs/common';
import { promises as fs } from 'fs';
import { join } from 'path';
import { createHash } from 'crypto';

/**
 * Fallback Storage Service
 * Provides local filesystem storage as fallback when Storacha is unavailable
 * 
 * Features:
 * - Local filesystem storage
 * - Retry queue for failed uploads
 * - Background job to retry failed uploads
 * 
 * Requirements: 12.4
 */
@Injectable()
export class FallbackStorageService {
  private readonly logger = new Logger(FallbackStorageService.name);
  private readonly fallbackDir = join(process.cwd(), 'storage', 'fallback');
  private readonly retryQueue: Map<string, RetryItem> = new Map();
  private retryInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.ensureFallbackDirectory();
    this.startRetryWorker();
  }

  /**
   * Ensure fallback directory exists
   */
  private async ensureFallbackDirectory() {
    try {
      await fs.mkdir(this.fallbackDir, { recursive: true });
      this.logger.log(`Fallback directory ready: ${this.fallbackDir}`);
    } catch (error) {
      this.logger.error(`Failed to create fallback directory: ${error}`);
    }
  }

  /**
   * Store file in local filesystem
   * Requirement 12.4: Implement local filesystem storage as fallback
   * 
   * @param buffer - File content
   * @param filename - Original filename
   * @returns Local file path
   */
  async storeLocally(buffer: Buffer, filename: string): Promise<string> {
    try {
      // Generate a unique filename using hash
      const hash = createHash('sha256').update(buffer).digest('hex');
      const localFilename = `${hash}_${filename}`;
      const localPath = join(this.fallbackDir, localFilename);

      // Write file to disk
      await fs.writeFile(localPath, buffer);

      this.logger.log(`File stored locally: ${localPath}`);
      return localPath;
    } catch (error) {
      this.logger.error(`Failed to store file locally: ${error}`);
      throw error;
    }
  }

  /**
   * Retrieve file from local filesystem
   * 
   * @param localPath - Local file path
   * @returns File content as Buffer
   */
  async retrieveLocally(localPath: string): Promise<Buffer> {
    try {
      const buffer = await fs.readFile(localPath);
      this.logger.log(`File retrieved locally: ${localPath}`);
      return buffer;
    } catch (error) {
      this.logger.error(`Failed to retrieve file locally: ${error}`);
      throw error;
    }
  }

  /**
   * Add file to retry queue
   * Requirement 12.4: Create retry queue for failed uploads
   * 
   * @param buffer - File content
   * @param filename - Original filename
   * @param localPath - Local storage path
   * @param uploadCallback - Function to retry upload
   */
  addToRetryQueue(
    buffer: Buffer,
    filename: string,
    localPath: string,
    uploadCallback: (buffer: Buffer, filename: string) => Promise<string>
  ) {
    const id = createHash('sha256').update(localPath).digest('hex');

    const retryItem: RetryItem = {
      id,
      buffer,
      filename,
      localPath,
      uploadCallback,
      attempts: 0,
      maxAttempts: 5,
      nextRetryAt: Date.now() + 60000, // Retry in 1 minute
    };

    this.retryQueue.set(id, retryItem);
    this.logger.log(`Added to retry queue: ${filename} (${id})`);
  }

  /**
   * Start background worker to retry failed uploads
   * Requirement 12.4: Add background job to retry failed uploads
   */
  private startRetryWorker() {
    // Check retry queue every 30 seconds
    this.retryInterval = setInterval(() => {
      this.processRetryQueue();
    }, 30000);

    this.logger.log('Retry worker started');
  }

  /**
   * Process retry queue
   */
  private async processRetryQueue() {
    const now = Date.now();
    const itemsToRetry: RetryItem[] = [];

    // Find items ready for retry
    for (const [id, item] of this.retryQueue.entries()) {
      if (item.nextRetryAt <= now) {
        itemsToRetry.push(item);
      }
    }

    if (itemsToRetry.length === 0) {
      return;
    }

    this.logger.log(`Processing ${itemsToRetry.length} items from retry queue`);

    // Process each item
    for (const item of itemsToRetry) {
      try {
        // Attempt upload
        const cid = await item.uploadCallback(item.buffer, item.filename);

        // Success! Remove from queue and delete local file
        this.retryQueue.delete(item.id);
        await this.deleteLocalFile(item.localPath);

        this.logger.log(
          `Successfully uploaded from retry queue: ${item.filename} -> ${cid}`
        );
      } catch (error) {
        // Failed, increment attempts
        item.attempts++;

        if (item.attempts >= item.maxAttempts) {
          // Max attempts reached, remove from queue
          this.retryQueue.delete(item.id);
          this.logger.error(
            `Max retry attempts reached for ${item.filename}, giving up`
          );
        } else {
          // Schedule next retry with exponential backoff
          const delay = Math.min(
            60000 * Math.pow(2, item.attempts), // 1min, 2min, 4min, 8min, 16min
            900000 // Max 15 minutes
          );
          item.nextRetryAt = Date.now() + delay;

          this.logger.warn(
            `Retry failed for ${item.filename} (attempt ${item.attempts}/${item.maxAttempts}), ` +
            `next retry in ${delay / 1000}s`
          );
        }
      }
    }
  }

  /**
   * Delete local file
   */
  private async deleteLocalFile(localPath: string) {
    try {
      await fs.unlink(localPath);
      this.logger.log(`Deleted local file: ${localPath}`);
    } catch (error) {
      this.logger.warn(`Failed to delete local file: ${localPath}`);
    }
  }

  /**
   * Get retry queue status
   */
  getRetryQueueStatus() {
    const items = Array.from(this.retryQueue.values()).map(item => ({
      filename: item.filename,
      attempts: item.attempts,
      maxAttempts: item.maxAttempts,
      nextRetryAt: new Date(item.nextRetryAt),
    }));

    return {
      queueSize: this.retryQueue.size,
      items,
    };
  }

  /**
   * Stop retry worker (for cleanup)
   */
  stopRetryWorker() {
    if (this.retryInterval) {
      clearInterval(this.retryInterval);
      this.retryInterval = null;
      this.logger.log('Retry worker stopped');
    }
  }
}

/**
 * Retry queue item interface
 */
interface RetryItem {
  id: string;
  buffer: Buffer;
  filename: string;
  localPath: string;
  uploadCallback: (buffer: Buffer, filename: string) => Promise<string>;
  attempts: number;
  maxAttempts: number;
  nextRetryAt: number;
}
