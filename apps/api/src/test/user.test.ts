// Generated by Kiro
import { prisma, cleanDatabase, closeDatabaseConnection } from './setup';

describe('User CRUD Operations', () => {
  beforeEach(async () => {
    await cleanDatabase();
  });

  afterAll(async () => {
    await closeDatabaseConnection();
  });

  describe('Create User', () => {
    it('should create a new user with all fields', async () => {
      const userData = {
        did: 'did:key:test123',
        username: 'ghosthunter',
        walletAddress: '0x1234567890123456789012345678901234567890',
      };

      const user = await prisma.user.create({
        data: userData,
      });

      expect(user.id).toBeDefined();
      expect(user.did).toBe(userData.did);
      expect(user.username).toBe(userData.username);
      expect(user.walletAddress).toBe(userData.walletAddress);
      expect(user.createdAt).toBeInstanceOf(Date);
      expect(user.updatedAt).toBeInstanceOf(Date);
    });

    it('should create a user without wallet address', async () => {
      const userData = {
        did: 'did:key:test456',
        username: 'spookyuser',
      };

      const user = await prisma.user.create({
        data: userData,
      });

      expect(user.id).toBeDefined();
      expect(user.walletAddress).toBeNull();
    });

    it('should reject duplicate DID', async () => {
      const userData = {
        did: 'did:key:duplicate',
        username: 'user1',
      };

      await prisma.user.create({ data: userData });

      await expect(
        prisma.user.create({
          data: {
            did: 'did:key:duplicate',
            username: 'user2',
          },
        })
      ).rejects.toThrow();
    });

    it('should reject duplicate username', async () => {
      const username = 'uniqueuser';

      await prisma.user.create({
        data: {
          did: 'did:key:test1',
          username,
        },
      });

      await expect(
        prisma.user.create({
          data: {
            did: 'did:key:test2',
            username,
          },
        })
      ).rejects.toThrow();
    });
  });

  describe('Read User', () => {
    it('should find user by ID', async () => {
      const created = await prisma.user.create({
        data: {
          did: 'did:key:findme',
          username: 'findableuser',
        },
      });

      const found = await prisma.user.findUnique({
        where: { id: created.id },
      });

      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
    });

    it('should find user by DID', async () => {
      const did = 'did:key:searchable';
      await prisma.user.create({
        data: {
          did,
          username: 'searchuser',
        },
      });

      const found = await prisma.user.findUnique({
        where: { did },
      });

      expect(found).toBeDefined();
      expect(found?.did).toBe(did);
    });

    it('should return null for non-existent user', async () => {
      const found = await prisma.user.findUnique({
        where: { id: 'non-existent-id' },
      });

      expect(found).toBeNull();
    });
  });

  describe('Update User', () => {
    it('should update user wallet address', async () => {
      const user = await prisma.user.create({
        data: {
          did: 'did:key:updateme',
          username: 'updateuser',
        },
      });

      const newWallet = '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd';
      const updated = await prisma.user.update({
        where: { id: user.id },
        data: { walletAddress: newWallet },
      });

      expect(updated.walletAddress).toBe(newWallet);
      expect(updated.updatedAt.getTime()).toBeGreaterThan(user.updatedAt.getTime());
    });
  });

  describe('Delete User', () => {
    it('should delete user', async () => {
      const user = await prisma.user.create({
        data: {
          did: 'did:key:deleteme',
          username: 'deleteuser',
        },
      });

      await prisma.user.delete({
        where: { id: user.id },
      });

      const found = await prisma.user.findUnique({
        where: { id: user.id },
      });

      expect(found).toBeNull();
    });

    it('should cascade delete related rooms', async () => {
      const user = await prisma.user.create({
        data: {
          did: 'did:key:cascade',
          username: 'cascadeuser',
        },
      });

      const room = await prisma.room.create({
        data: {
          ownerId: user.id,
          inputText: 'Test',
          status: 'idle',
        },
      });

      await prisma.user.delete({
        where: { id: user.id },
      });

      const foundRoom = await prisma.room.findUnique({
        where: { id: room.id },
      });

      expect(foundRoom).toBeNull();
    });
  });
});
