// Feature: haunted-ai, Property 39, 40, 41: Authentication Flow
// Validates: Requirements 11.1, 11.2, 11.3
// Generated by Kiro - Property-Based Tests

import * as fc from 'fast-check';

// Mock localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};

  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value;
    },
    removeItem: (key: string) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    },
  };
})();

Object.defineProperty(global, 'localStorage', {
  value: localStorageMock,
});

// Mock window.ethereum for Web3
const mockEthereum = {
  request: jest.fn(),
  on: jest.fn(),
};

Object.defineProperty(global, 'window', {
  value: {
    ethereum: mockEthereum,
  },
  writable: true,
});

// Mock fetch for API calls
global.fetch = jest.fn();

// Mock Web3Manager
class MockWeb3Manager {
  async isMetaMaskInstalled(): Promise<boolean> {
    return true;
  }

  async connectWallet(): Promise<{ address: string; chainId: string } | null> {
    const accounts = await mockEthereum.request({ method: 'eth_requestAccounts' });
    if (!accounts || accounts.length === 0) {
      return null;
    }
    const chainId = await mockEthereum.request({ method: 'eth_chainId' });
    return {
      address: accounts[0],
      chainId,
    };
  }

  async signMessage(address: string, message: string): Promise<string | null> {
    const signature = await mockEthereum.request({
      method: 'personal_sign',
      params: [message, address],
    });
    return signature;
  }
}

// Mock API Client
class MockApiClient {
  private token: string | null = null;

  setToken(token: string) {
    this.token = token;
    localStorage.setItem('jwt_token', token);
  }

  clearToken() {
    this.token = null;
    localStorage.removeItem('jwt_token');
  }

  async login(walletAddress: string, signature: string, message: string) {
    const response = await fetch('/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ walletAddress, signature, message }),
    });

    if (!response.ok) {
      return { error: 'Login failed', status: response.status };
    }

    const data = await response.json();
    return { data, status: response.status };
  }
}

describe('Authentication Flow Property-Based Tests', () => {
  let web3Manager: MockWeb3Manager;
  let apiClient: MockApiClient;

  beforeEach(() => {
    web3Manager = new MockWeb3Manager();
    apiClient = new MockApiClient();
    localStorage.clear();
    jest.clearAllMocks();
  });

  afterEach(() => {
    localStorage.clear();
  });

  // Feature: haunted-ai, Property 39: Wallet connection triggers signature request
  // Validates: Requirements 11.1
  describe('Property 39: Wallet connection triggers signature request', () => {
    it('should trigger signature request for any wallet connection', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          fc.string({ minLength: 10, maxLength: 100 }),
          async (addressSuffix: string, message: string) => {
            // Reset mocks
            jest.clearAllMocks();

            const walletAddress = `0x${addressSuffix}`;
            const chainId = '0x1';

            // Mock wallet connection
            mockEthereum.request.mockImplementation((params: any) => {
              if (params.method === 'eth_requestAccounts') {
                return Promise.resolve([walletAddress]);
              }
              if (params.method === 'eth_chainId') {
                return Promise.resolve(chainId);
              }
              if (params.method === 'personal_sign') {
                return Promise.resolve(`0x${'a'.repeat(130)}`); // Mock signature
              }
              return Promise.reject(new Error('Unknown method'));
            });

            // Connect wallet
            const connection = await web3Manager.connectWallet();
            expect(connection).not.toBeNull();
            expect(connection?.address).toBe(walletAddress);

            // Request signature
            const signature = await web3Manager.signMessage(walletAddress, message);

            // Property: Wallet connection should trigger signature request
            expect(mockEthereum.request).toHaveBeenCalledWith({
              method: 'personal_sign',
              params: [message, walletAddress],
            });
            expect(signature).not.toBeNull();
            expect(signature).toMatch(/^0x[a-f0-9]+$/i);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle wallet connection rejection', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.string({ minLength: 10, maxLength: 100 }),
          async (message: string) => {
            // Reset mocks
            jest.clearAllMocks();

            // Mock wallet rejection
            mockEthereum.request.mockRejectedValue(new Error('User rejected'));

            // Try to connect wallet (should catch error internally)
            try {
              const connection = await web3Manager.connectWallet();
              // Property: Rejected connection should return null
              expect(connection).toBeNull();
            } catch (error) {
              // If error is thrown, that's also acceptable behavior
              expect(error).toBeDefined();
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle signature rejection', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          fc.string({ minLength: 10, maxLength: 100 }),
          async (addressSuffix: string, message: string) => {
            // Reset mocks
            jest.clearAllMocks();

            const walletAddress = `0x${addressSuffix}`;

            // Mock signature rejection
            mockEthereum.request.mockRejectedValue(new Error('User rejected signature'));

            // Try to sign message (should catch error internally)
            try {
              const signature = await web3Manager.signMessage(walletAddress, message);
              // Property: Rejected signature should return null
              expect(signature).toBeNull();
            } catch (error) {
              // If error is thrown, that's also acceptable behavior
              expect(error).toBeDefined();
            }
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  // Feature: haunted-ai, Property 40: Valid signature issues JWT
  // Validates: Requirements 11.2
  describe('Property 40: Valid signature issues JWT', () => {
    it('should issue JWT token for any valid signature', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          fc.string({ minLength: 5, maxLength: 20 }),
          fc.string({ minLength: 10, maxLength: 100 }),
          async (addressSuffix: string, username: string, message: string) => {
            // Reset mocks
            jest.clearAllMocks();

            const walletAddress = `0x${addressSuffix}`;
            const signature = `0x${'a'.repeat(130)}`;
            const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
              JSON.stringify({ sub: walletAddress, username })
            ).toString('base64')}.signature`;

            // Mock successful login
            (global.fetch as jest.Mock).mockResolvedValue({
              ok: true,
              status: 200,
              json: async () => ({
                accessToken: mockJWT,
                user: {
                  id: `user-${Date.now()}`,
                  did: `did:ethr:${walletAddress.toLowerCase()}`,
                  username: username.replace(/[^a-zA-Z0-9]/g, '_'),
                  walletAddress: walletAddress.toLowerCase(),
                },
              }),
            });

            // Login with signature
            const response = await apiClient.login(walletAddress, signature, message);

            // Property: Valid signature should result in JWT token
            expect(response.data).toBeDefined();
            expect(response.data.accessToken).toBeDefined();
            // JWT format: header.payload.signature (base64 encoded parts)
            expect(response.data.accessToken).toMatch(/^eyJ.+\..+\..+$/);
            expect(response.data.user).toBeDefined();
            expect(response.data.user.walletAddress).toBe(walletAddress.toLowerCase());
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should reject invalid signatures', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          fc.string({ minLength: 10, maxLength: 100 }),
          async (addressSuffix: string, message: string) => {
            // Reset mocks
            jest.clearAllMocks();

            const walletAddress = `0x${addressSuffix}`;
            const invalidSignature = '0xinvalid';

            // Mock failed login
            (global.fetch as jest.Mock).mockResolvedValue({
              ok: false,
              status: 401,
              json: async () => ({
                message: 'Invalid signature',
              }),
            });

            // Try to login with invalid signature
            const response = await apiClient.login(walletAddress, invalidSignature, message);

            // Property: Invalid signature should not issue JWT
            expect(response.error).toBeDefined();
            expect(response.status).toBe(401);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should generate unique JWT for different wallets', async () => {
      const tokens = new Set<string>();

      await fc.assert(
        fc.asyncProperty(
          fc.array(
            fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
              arr.map(n => n.toString(16)).join('')
            ),
            { minLength: 2, maxLength: 10 }
          ),
          fc.string({ minLength: 10, maxLength: 100 }),
          async (addressSuffixes: string[], message: string) => {
            // Reset mocks
            jest.clearAllMocks();
            tokens.clear();

            for (const addressSuffix of addressSuffixes) {
              const walletAddress = `0x${addressSuffix}`;
              const signature = `0x${'a'.repeat(130)}`;
              const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
                JSON.stringify({ sub: walletAddress, timestamp: Date.now() })
              ).toString('base64')}.signature`;

              (global.fetch as jest.Mock).mockResolvedValue({
                ok: true,
                status: 200,
                json: async () => ({
                  accessToken: mockJWT,
                  user: {
                    id: `user-${walletAddress}`,
                    did: `did:ethr:${walletAddress.toLowerCase()}`,
                    username: `user_${addressSuffix.slice(0, 6)}`,
                    walletAddress: walletAddress.toLowerCase(),
                  },
                }),
              });

              const response = await apiClient.login(walletAddress, signature, message);

              if (response.data) {
                // Property: Each wallet should get a unique JWT
                expect(tokens.has(response.data.accessToken)).toBe(false);
                tokens.add(response.data.accessToken);
              }
            }
          }
        ),
        { numRuns: 50 }
      );
    });
  });

  // Feature: haunted-ai, Property 41: JWT storage and usage
  // Validates: Requirements 11.3
  describe('Property 41: JWT storage and usage', () => {
    it('should store JWT in localStorage after successful login', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          fc.string({ minLength: 10, maxLength: 100 }),
          async (addressSuffix: string, message: string) => {
            // Reset mocks and storage
            jest.clearAllMocks();
            localStorage.clear();

            const walletAddress = `0x${addressSuffix}`;
            const signature = `0x${'a'.repeat(130)}`;
            const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
              JSON.stringify({ sub: walletAddress })
            ).toString('base64')}.signature`;

            (global.fetch as jest.Mock).mockResolvedValue({
              ok: true,
              status: 200,
              json: async () => ({
                accessToken: mockJWT,
                user: {
                  id: `user-${Date.now()}`,
                  did: `did:ethr:${walletAddress.toLowerCase()}`,
                  username: `user_${addressSuffix.slice(0, 6)}`,
                  walletAddress: walletAddress.toLowerCase(),
                },
              }),
            });

            // Login
            const response = await apiClient.login(walletAddress, signature, message);

            if (response.data) {
              // Store token
              apiClient.setToken(response.data.accessToken);

              // Property: JWT should be stored in localStorage
              const storedToken = localStorage.getItem('jwt_token');
              expect(storedToken).toBe(response.data.accessToken);
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should include JWT in subsequent API requests', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          async (addressSuffix: string) => {
            // Reset mocks and storage
            jest.clearAllMocks();
            localStorage.clear();

            const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
              JSON.stringify({ sub: `0x${addressSuffix}` })
            ).toString('base64')}.signature`;

            // Store token
            apiClient.setToken(mockJWT);

            // Verify token is in localStorage
            const storedToken = localStorage.getItem('jwt_token');

            // Property: Stored JWT should be retrievable from localStorage
            expect(storedToken).toBe(mockJWT);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should clear JWT from localStorage on logout', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          async (addressSuffix: string) => {
            // Reset mocks and storage
            jest.clearAllMocks();
            localStorage.clear();

            const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
              JSON.stringify({ sub: `0x${addressSuffix}` })
            ).toString('base64')}.signature`;

            // Store token
            apiClient.setToken(mockJWT);
            expect(localStorage.getItem('jwt_token')).toBe(mockJWT);

            // Logout
            apiClient.clearToken();

            // Property: JWT should be removed from localStorage after logout
            const storedToken = localStorage.getItem('jwt_token');
            expect(storedToken).toBeNull();
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should persist JWT across page reloads', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          async (addressSuffix: string) => {
            // Reset mocks and storage
            jest.clearAllMocks();
            localStorage.clear();

            const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
              JSON.stringify({ sub: `0x${addressSuffix}` })
            ).toString('base64')}.signature`;

            // Store token
            apiClient.setToken(mockJWT);

            // Simulate page reload by creating new client instance
            const newApiClient = new MockApiClient();

            // Property: JWT should persist in localStorage after reload
            const storedToken = localStorage.getItem('jwt_token');
            expect(storedToken).toBe(mockJWT);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle JWT expiration gracefully', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          async (addressSuffix: string) => {
            // Reset mocks and storage
            jest.clearAllMocks();
            localStorage.clear();

            const expiredJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
              JSON.stringify({ sub: `0x${addressSuffix}`, exp: Date.now() / 1000 - 3600 })
            ).toString('base64')}.signature`;

            // Store expired token
            apiClient.setToken(expiredJWT);

            // Mock 401 response for expired token
            (global.fetch as jest.Mock).mockResolvedValue({
              ok: false,
              status: 401,
              json: async () => ({
                message: 'Token expired',
              }),
            });

            // Try to make authenticated request
            const response = await fetch('/api/protected', {
              headers: {
                Authorization: `Bearer ${expiredJWT}`,
              },
            });

            // Property: Expired JWT should result in 401 status
            expect(response.status).toBe(401);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should maintain user data consistency with JWT', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
            arr.map(n => n.toString(16)).join('')
          ),
          fc.string({ minLength: 5, maxLength: 20 }),
          async (addressSuffix: string, username: string) => {
            // Reset mocks and storage
            jest.clearAllMocks();
            localStorage.clear();

            const walletAddress = `0x${addressSuffix}`;
            const userData = {
              id: `user-${Date.now()}`,
              did: `did:ethr:${walletAddress.toLowerCase()}`,
              username: username.replace(/[^a-zA-Z0-9]/g, '_'),
              walletAddress: walletAddress.toLowerCase(),
            };

            const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
              JSON.stringify({ sub: walletAddress, username: userData.username })
            ).toString('base64')}.signature`;

            // Store token and user data
            apiClient.setToken(mockJWT);
            localStorage.setItem('user', JSON.stringify(userData));

            // Retrieve stored data
            const storedToken = localStorage.getItem('jwt_token');
            const storedUser = JSON.parse(localStorage.getItem('user') || '{}');

            // Property: User data should be consistent with JWT payload
            expect(storedToken).toBe(mockJWT);
            expect(storedUser.walletAddress).toBe(walletAddress.toLowerCase());
            expect(storedUser.username).toBe(userData.username);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle multiple login/logout cycles', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.array(
            fc.array(fc.integer({ min: 0, max: 15 }), { minLength: 40, maxLength: 40 }).map(arr => 
              arr.map(n => n.toString(16)).join('')
            ),
            { minLength: 2, maxLength: 5 }
          ),
          async (addressSuffixes: string[]) => {
            // Reset mocks and storage
            jest.clearAllMocks();
            localStorage.clear();

            for (const addressSuffix of addressSuffixes) {
              const mockJWT = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${Buffer.from(
                JSON.stringify({ sub: `0x${addressSuffix}` })
              ).toString('base64')}.signature`;

              // Login
              apiClient.setToken(mockJWT);
              expect(localStorage.getItem('jwt_token')).toBe(mockJWT);

              // Logout
              apiClient.clearToken();
              expect(localStorage.getItem('jwt_token')).toBeNull();
            }

            // Property: After multiple cycles, storage should be clean
            expect(localStorage.getItem('jwt_token')).toBeNull();
          }
        ),
        { numRuns: 50 }
      );
    });
  });
});
