// Generated by Kiro - Unit Tests for Orchestrator Timeout Functionality
// Requirements: 12.1

import { OrchestratorService } from './orchestrator.service';

describe('Orchestrator Timeout Tests', () => {
  let orchestrator: OrchestratorService;
  let logEmitterMock: jest.Mock;
  let updateRoomStatusMock: jest.Mock;
  let rewardUserMock: jest.Mock;
  let callAgentSpy: jest.SpyInstance;
  let timeoutIds: NodeJS.Timeout[] = [];

  beforeEach(() => {
    jest.clearAllMocks();
    timeoutIds = [];

    logEmitterMock = jest.fn().mockResolvedValue(undefined);
    updateRoomStatusMock = jest.fn().mockResolvedValue(undefined);
    rewardUserMock = jest.fn().mockResolvedValue(undefined);

    orchestrator = new OrchestratorService(logEmitterMock, updateRoomStatusMock, rewardUserMock);

    // Spy on private method callAgent
    callAgentSpy = jest.spyOn(orchestrator as any, 'callAgent');

    // Mock sleep to avoid actual delays
    jest.spyOn(orchestrator as any, 'sleep').mockResolvedValue(undefined);

    // Track and clear timeouts created by callAgentWithTimeout
    const originalSetTimeout = global.setTimeout;
    jest.spyOn(global, 'setTimeout').mockImplementation((fn: any, delay?: number, ...args: any[]) => {
      const id = originalSetTimeout(fn, delay, ...args);
      timeoutIds.push(id);
      return id;
    });
  });

  afterEach(async () => {
    // Clear all tracked timeouts
    timeoutIds.forEach(id => clearTimeout(id));
    timeoutIds = [];

    jest.restoreAllMocks();
    jest.clearAllTimers();
    jest.useRealTimers();
    
    // Wait a bit for any async operations to complete
    await new Promise(resolve => setTimeout(resolve, 10));
  });

  describe('Agent Timeout Configuration', () => {
    it('should have correct timeout for StoryAgent (30s)', () => {
      const config = (orchestrator as any).AGENT_CONFIGS.StoryAgent;
      expect(config.timeout).toBe(30000);
    });

    it('should have correct timeout for AssetAgent (60s)', () => {
      const config = (orchestrator as any).AGENT_CONFIGS.AssetAgent;
      expect(config.timeout).toBe(60000);
    });

    it('should have correct timeout for CodeAgent (60s)', () => {
      const config = (orchestrator as any).AGENT_CONFIGS.CodeAgent;
      expect(config.timeout).toBe(60000);
    });

    it('should have correct timeout for DeployAgent (120s)', () => {
      const config = (orchestrator as any).AGENT_CONFIGS.DeployAgent;
      expect(config.timeout).toBe(120000);
    });
  });

  describe('Timeout Enforcement', () => {
    it('should timeout agent that exceeds configured timeout', async () => {
      const roomId = 'test-room-123';
      const userInput = 'test input';

      // Mock agent to throw timeout error
      callAgentSpy.mockRejectedValue(new Error('StoryAgent timeout after 30000ms'));

      // Execute workflow (should handle timeout)
      await orchestrator.executeWorkflow(roomId, userInput);

      // Verify error was logged
      const errorLogs = logEmitterMock.mock.calls.filter(
        (call) => call[2] === 'error'
      );
      expect(errorLogs.length).toBeGreaterThan(0);

      // Verify room status was set to error
      expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'error');
    });

    it('should complete successfully if agent finishes before timeout', async () => {
      const roomId = 'test-room-456';
      const userInput = 'test input';

      // Mock agent to complete quickly
      callAgentSpy.mockResolvedValue({
        success: true,
        data: { result: 'success' },
      });

      // Execute workflow
      await orchestrator.executeWorkflow(roomId, userInput);

      // Verify workflow completed successfully
      expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'done');
      expect(rewardUserMock).toHaveBeenCalledWith(roomId, 10);
    });

    it('should log timeout error with agent name', async () => {
      const roomId = 'test-room-789';
      const userInput = 'test input';

      let callCount = 0;

      // Mock first agent to timeout
      callAgentSpy.mockImplementation(async (config) => {
        callCount++;
        if (callCount === 1) {
          // Simulate timeout by throwing timeout error
          throw new Error(`${config.name} timeout after ${config.timeout}ms`);
        }
        return { success: true, data: {} };
      });

      // Execute workflow
      await orchestrator.executeWorkflow(roomId, userInput);

      // Verify error was logged (may not contain "timeout" in message but should log the error)
      const warnLogs = logEmitterMock.mock.calls.filter(
        (call) => call[2] === 'warn' && call[3].includes('retrying')
      );
      expect(warnLogs.length).toBeGreaterThan(0);
    });

    it('should retry agent after timeout', async () => {
      const roomId = 'test-room-retry';
      const userInput = 'test input';

      let attemptCount = 0;

      // Mock agent to timeout once then succeed
      callAgentSpy.mockImplementation(async (config) => {
        attemptCount++;
        if (attemptCount === 1) {
          throw new Error(`${config.name} timeout after ${config.timeout}ms`);
        }
        return { success: true, data: {} };
      });

      // Execute workflow
      await orchestrator.executeWorkflow(roomId, userInput);

      // Verify agent was retried
      expect(attemptCount).toBeGreaterThan(1);

      // Verify workflow completed successfully after retry
      expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'done');
    });

    it('should fail workflow after all timeout retries exhausted', async () => {
      const roomId = 'test-room-exhausted';
      const userInput = 'test input';

      // Mock agent to always timeout
      callAgentSpy.mockImplementation(async (config) => {
        throw new Error(`${config.name} timeout after ${config.timeout}ms`);
      });

      // Execute workflow
      await orchestrator.executeWorkflow(roomId, userInput);

      // Verify workflow failed
      expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'error');

      // Verify error log mentions timeout
      const errorLogs = logEmitterMock.mock.calls.filter(
        (call) => call[2] === 'error' && call[3].includes('failed after')
      );
      expect(errorLogs.length).toBeGreaterThan(0);
    });
  });

  describe('Timeout Duration Tracking', () => {
    it('should track duration of agent execution', async () => {
      const roomId = 'test-room-duration';
      const userInput = 'test input';

      // Mock agent to complete with duration
      callAgentSpy.mockResolvedValue({
        success: true,
        data: { result: 'success' },
      });

      // Execute workflow
      await orchestrator.executeWorkflow(roomId, userInput);

      // Verify success logs include duration metadata
      const successLogs = logEmitterMock.mock.calls.filter(
        (call) => call[2] === 'success' && call[3].includes('completed successfully')
      );

      expect(successLogs.length).toBeGreaterThan(0);
      // Duration should be in metadata
      expect(successLogs[0][4]).toHaveProperty('duration');
    });
  });
});
