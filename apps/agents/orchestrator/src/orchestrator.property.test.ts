// Generated by Kiro - Property-Based Tests for Orchestrator
// Requirements: 12.1, 12.2

import * as fc from 'fast-check';
import { OrchestratorService } from './orchestrator.service';
import { WorkflowState } from './types';

describe('Orchestrator Property-Based Tests', () => {
  let orchestrator: OrchestratorService;
  let logEmitterMock: jest.Mock;
  let updateRoomStatusMock: jest.Mock;
  let rewardUserMock: jest.Mock;
  let callAgentSpy: jest.SpyInstance;

  beforeEach(() => {
    jest.clearAllMocks();

    logEmitterMock = jest.fn().mockResolvedValue(undefined);
    updateRoomStatusMock = jest.fn().mockResolvedValue(undefined);
    rewardUserMock = jest.fn().mockResolvedValue(undefined);

    orchestrator = new OrchestratorService(logEmitterMock, updateRoomStatusMock, rewardUserMock);

    // Spy on private method callAgent
    callAgentSpy = jest.spyOn(orchestrator as any, 'callAgent');

    // Mock sleep to avoid actual delays in tests
    jest.spyOn(orchestrator as any, 'sleep').mockResolvedValue(undefined);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  // Feature: haunted-ai, Property 44: Agent retry with exponential backoff
  // Validates: Requirements 12.1
  describe('Property 44: Agent retry with exponential backoff', () => {
    it('should retry failed agents with exponentially increasing delays', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
            failureCount: fc.integer({ min: 1, max: 2 }), // Fail 1-2 times before success
          }),
          async ({ roomId, userInput, failureCount }) => {
            jest.clearAllMocks();

            let storyAgentAttempts = 0;
            const sleepDelays: number[] = [];

            // Mock sleep to capture delays
            const sleepSpy = jest.spyOn(orchestrator as any, 'sleep').mockImplementation(async (...args: any[]) => {
              sleepDelays.push(args[0] as number);
              return Promise.resolve();
            });

            // Mock agent to fail N times then succeed (only for StoryAgent)
            callAgentSpy.mockImplementation(async (config) => {
              if (config.name === 'StoryAgent') {
                storyAgentAttempts++;

                if (storyAgentAttempts <= failureCount) {
                  throw new Error(`Temporary failure ${storyAgentAttempts}`);
                }
              }

              return {
                success: true,
                data: { result: 'success' },
              };
            });

            // Execute workflow
            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: Should retry exactly failureCount times before success
            expect(storyAgentAttempts).toBe(failureCount + 1);

            // Property: Delays should follow exponential backoff pattern (2s, 4s, 8s)
            expect(sleepDelays.length).toBe(failureCount);
            for (let i = 0; i < sleepDelays.length; i++) {
              const expectedDelay = 2000 * Math.pow(2, i); // 2s, 4s, 8s
              expect(sleepDelays[i]).toBe(expectedDelay);
            }

            // Property: Workflow should complete successfully after retries
            expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'done');

            sleepSpy.mockRestore();
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);

    it('should respect maximum retry attempts of 3', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            let attemptCount = 0;

            // Mock agent to always fail
            callAgentSpy.mockImplementation(async () => {
              attemptCount++;
              throw new Error(`Persistent failure ${attemptCount}`);
            });

            // Execute workflow (should fail)
            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: Should attempt exactly 3 times (max retries)
            expect(attemptCount).toBe(3);

            // Property: Room status should be set to error after all retries exhausted
            expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'error');

            // Property: Error log should be emitted
            const errorLogs = logEmitterMock.mock.calls.filter(
              (call) => call[2] === 'error' && call[3].includes('failed after')
            );
            expect(errorLogs.length).toBeGreaterThan(0);
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);

    it('should calculate exponential backoff correctly for all retry attempts', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            const delays: number[] = [];
            let attemptCount = 0;

            // Mock agent to fail twice then succeed
            callAgentSpy.mockImplementation(async () => {
              attemptCount++;
              if (attemptCount <= 2) {
                throw new Error(`Failure ${attemptCount}`);
              }
              return { success: true, data: {} };
            });

            // Spy on sleep to capture delays
            const sleepSpy = jest.spyOn(orchestrator as any, 'sleep').mockImplementation(async (...args: any[]) => {
              delays.push(args[0] as number);
              return Promise.resolve();
            });

            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: First retry delay should be 2000ms (2s)
            if (delays.length >= 1) {
              expect(delays[0]).toBe(2000);
            }

            // Property: Second retry delay should be 4000ms (4s)
            if (delays.length >= 2) {
              expect(delays[1]).toBe(4000);
            }

            // Property: Delays should follow pattern: 2s, 4s, 8s
            const expectedDelays = [2000, 4000, 8000];
            for (let i = 0; i < Math.min(delays.length, 3); i++) {
              expect(delays[i]).toBe(expectedDelays[i]);
            }

            sleepSpy.mockRestore();
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);

    it('should emit warning logs with retry information', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            let attemptCount = 0;

            // Mock agent to fail once then succeed
            callAgentSpy.mockImplementation(async () => {
              attemptCount++;
              if (attemptCount === 1) {
                throw new Error('Temporary failure');
              }
              return { success: true, data: {} };
            });

            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: Warning log should be emitted for retry
            const warnLogs = logEmitterMock.mock.calls.filter(
              (call) => call[2] === 'warn' && call[3].includes('retrying in')
            );
            expect(warnLogs.length).toBeGreaterThan(0);

            // Property: Warning log should include delay information
            const warnLog = warnLogs[0];
            expect(warnLog[3]).toMatch(/\d+ms/);
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);
  });

  // Feature: haunted-ai, Property 45: Workflow continuation after agent failure
  // Validates: Requirements 12.2
  describe('Property 45: Workflow continuation after agent failure', () => {
    it('should mark failed agents and continue workflow when possible', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            // Mock first agent to always fail
            callAgentSpy.mockRejectedValue(new Error('Persistent agent failure'));

            // Execute workflow
            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: Room status should be set to error
            expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'error');

            // Property: Error log should include failed agent information
            const errorLogs = logEmitterMock.mock.calls.filter((call) => call[2] === 'error');
            expect(errorLogs.length).toBeGreaterThan(0);

            const workflowErrorLog = errorLogs.find((call) => call[3] === 'Workflow failed');
            expect(workflowErrorLog).toBeDefined();
            expect(workflowErrorLog[4]).toHaveProperty('failedAgents');
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);

    it('should log all completed agents before failure', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            let callCount = 0;

            // Mock: first agent succeeds, second agent fails
            callAgentSpy.mockImplementation(async (config) => {
              callCount++;
              if (callCount === 1) {
                // StoryAgent succeeds
                return { success: true, data: { story: 'test story' } };
              }
              // AssetAgent fails
              throw new Error('Asset generation failed');
            });

            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: Error log should include completed agents
            const errorLogs = logEmitterMock.mock.calls.filter((call) => call[2] === 'error');
            const workflowErrorLog = errorLogs.find((call) => call[3] === 'Workflow failed');

            expect(workflowErrorLog).toBeDefined();
            expect(workflowErrorLog[4]).toHaveProperty('completedAgents');
            expect(workflowErrorLog[4].completedAgents).toContain('StoryAgent');
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);

    it('should not throw unhandled errors when workflow fails', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            // Mock agent to always fail
            callAgentSpy.mockRejectedValue(new Error('Critical failure'));

            // Property: executeWorkflow should not throw (error recovery)
            await expect(orchestrator.executeWorkflow(roomId, userInput)).resolves.not.toThrow();

            // Property: Error should be logged instead of thrown
            expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'error');
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);

    it('should complete workflow successfully when all agents succeed', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            // Mock all agents to succeed
            callAgentSpy.mockResolvedValue({
              success: true,
              data: { result: 'success' },
            });

            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: Room status should be set to done
            expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'done');

            // Property: User should be rewarded
            expect(rewardUserMock).toHaveBeenCalledWith(roomId, 10);

            // Property: Success log should be emitted
            const successLogs = logEmitterMock.mock.calls.filter(
              (call) => call[2] === 'success' && call[3].includes('completed successfully')
            );
            expect(successLogs.length).toBeGreaterThan(0);
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);

    it('should track retry count for each agent independently', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            userInput: fc.string({ minLength: 1, maxLength: 500 }),
          }),
          async ({ roomId, userInput }) => {
            jest.clearAllMocks();

            const agentAttempts: Record<string, number> = {};

            // Mock agents with different failure patterns
            callAgentSpy.mockImplementation(async (config) => {
              const agentName = config.name;
              agentAttempts[agentName] = (agentAttempts[agentName] || 0) + 1;

              // StoryAgent: fail once then succeed
              if (agentName === 'StoryAgent' && agentAttempts[agentName] <= 1) {
                throw new Error('Story failure');
              }

              // AssetAgent: fail twice then succeed
              if (agentName === 'AssetAgent' && agentAttempts[agentName] <= 2) {
                throw new Error('Asset failure');
              }

              return { success: true, data: {} };
            });

            await orchestrator.executeWorkflow(roomId, userInput);

            // Property: Each agent should have independent retry counts
            expect(agentAttempts.StoryAgent).toBe(2); // 1 failure + 1 success
            expect(agentAttempts.AssetAgent).toBe(3); // 2 failures + 1 success

            // Property: Workflow should complete successfully
            expect(updateRoomStatusMock).toHaveBeenCalledWith(roomId, 'done');
          }
        ),
        { numRuns: 100 }
      );
    }, 30000);
  });
});
