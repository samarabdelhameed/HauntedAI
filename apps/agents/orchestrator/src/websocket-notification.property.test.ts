// Generated by Kiro - Property-Based Tests for WebSocket Notifications
// Requirements: 4.3

import * as fc from 'fast-check';
import { createServer, Server as HttpServer } from 'http';
import ioClient from 'socket.io-client';
import { WebSocketNotificationService } from './websocket-notification.service';

type ClientSocket = ReturnType<typeof ioClient>;

describe('WebSocket Notification Property-Based Tests', () => {
  let httpServer: HttpServer;
  let wsService: WebSocketNotificationService;
  let serverPort: number;

  beforeEach((done) => {
    // Create HTTP server
    httpServer = createServer();
    
    // Find available port
    httpServer.listen(0, () => {
      const address = httpServer.address();
      serverPort = typeof address === 'object' && address !== null ? address.port : 3000;
      
      // Create WebSocket service
      wsService = new WebSocketNotificationService(httpServer, '*');
      
      done();
    });
  });

  afterEach(async () => {
    await wsService.close();
    await new Promise<void>((resolve) => {
      httpServer.close(() => resolve());
    });
  });

  // Feature: haunted-ai, Property 14: Deployment WebSocket notification
  // Validates: Requirements 4.3
  describe('Property 14: Deployment WebSocket notification', () => {
    it('should send deployment notification to all connected clients in room', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            deploymentUrl: fc.webUrl(),
            codeCid: fc.string({ minLength: 59, maxLength: 59 }).map(s => 'bafy' + s.toLowerCase().replace(/[^a-z0-9]/g, '2')),
          }),
          async ({ roomId, deploymentUrl, codeCid }) => {
            // Create client and connect
            const client = ioClient(`http://localhost:${serverPort}`, {
              transports: ['websocket'],
            });

            // Wait for connection
            await new Promise<void>((resolve) => {
              client.on('connect', () => resolve());
            });

            // Authenticate
            client.emit('authenticate', { roomId });

            // Wait for authentication
            await new Promise<void>((resolve) => {
              client.on('authenticated', () => resolve());
            });

            // Setup notification listener
            const receivedNotifications: any[] = [];
            client.on('notification', (notification: any) => {
              receivedNotifications.push(notification);
            });

            // Send deployment notification
            await wsService.sendDeploymentNotification(roomId, deploymentUrl, codeCid);

            // Wait a bit for message to be received
            await new Promise(resolve => setTimeout(resolve, 100));

            // Property: Client should receive exactly one notification
            expect(receivedNotifications.length).toBe(1);

            // Property: Notification should have correct type
            expect(receivedNotifications[0].type).toBe('deployment.complete');

            // Property: Notification should include deployment URL
            expect(receivedNotifications[0].deploymentUrl).toBe(deploymentUrl);

            // Property: Notification should include code CID
            expect(receivedNotifications[0].codeCid).toBe(codeCid);

            // Property: Notification should include room ID
            expect(receivedNotifications[0].roomId).toBe(roomId);

            // Property: Notification should have timestamp
            expect(receivedNotifications[0].timestamp).toBeDefined();

            // Cleanup
            client.disconnect();
          }
        ),
        { numRuns: 20 } // Reduced runs for WebSocket tests
      );
    }, 60000);

    it('should send notification to multiple clients in same room', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            deploymentUrl: fc.webUrl(),
            codeCid: fc.string({ minLength: 59, maxLength: 59 }).map(s => 'bafy' + s),
            clientCount: fc.integer({ min: 2, max: 3 }),
          }),
          async ({ roomId, deploymentUrl, codeCid, clientCount }) => {
            // Create multiple clients
            const clients: ClientSocket[] = [];
            const receivedNotifications: any[][] = [];

            for (let i = 0; i < clientCount; i++) {
              const client = ioClient(`http://localhost:${serverPort}`, {
                transports: ['websocket'],
              });

              // Wait for connection
              await new Promise<void>((resolve) => {
                client.on('connect', () => resolve());
              });

              // Authenticate
              client.emit('authenticate', { roomId });

              // Wait for authentication
              await new Promise<void>((resolve) => {
                client.on('authenticated', () => resolve());
              });

              // Setup notification listener
              const notifications: any[] = [];
              client.on('notification', (notification: any) => {
                notifications.push(notification);
              });

              clients.push(client);
              receivedNotifications.push(notifications);
            }

            // Send deployment notification
            await wsService.sendDeploymentNotification(roomId, deploymentUrl, codeCid);

            // Wait for messages to be received
            await new Promise(resolve => setTimeout(resolve, 200));

            // Property: All clients should receive the notification
            for (let i = 0; i < clientCount; i++) {
              expect(receivedNotifications[i].length).toBe(1);
              expect(receivedNotifications[i][0].type).toBe('deployment.complete');
              expect(receivedNotifications[i][0].deploymentUrl).toBe(deploymentUrl);
            }

            // Property: Connected clients count should match
            expect(wsService.getConnectedClientsCount(roomId)).toBe(clientCount);

            // Cleanup
            for (const client of clients) {
              client.disconnect();
            }
          }
        ),
        { numRuns: 10 } // Reduced runs for multi-client tests
      );
    }, 60000);

    it('should not send notification to clients in different rooms', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId1: fc.string({ minLength: 5, maxLength: 50 }),
            roomId2: fc.string({ minLength: 5, maxLength: 50 }),
            deploymentUrl: fc.webUrl(),
            codeCid: fc.string({ minLength: 59, maxLength: 59 }).map(s => 'bafy' + s),
          }),
          async ({ roomId1, roomId2, deploymentUrl, codeCid }) => {
            // Ensure rooms are different
            if (roomId1 === roomId2) {
              return; // Skip this test case
            }

            // Create client for room 1
            const client1 = ioClient(`http://localhost:${serverPort}`, {
              transports: ['websocket'],
            });

            await new Promise<void>((resolve) => {
              client1.on('connect', () => resolve());
            });

            client1.emit('authenticate', { roomId: roomId1 });

            await new Promise<void>((resolve) => {
              client1.on('authenticated', () => resolve());
            });

            // Create client for room 2
            const client2 = ioClient(`http://localhost:${serverPort}`, {
              transports: ['websocket'],
            });

            await new Promise<void>((resolve) => {
              client2.on('connect', () => resolve());
            });

            client2.emit('authenticate', { roomId: roomId2 });

            await new Promise<void>((resolve) => {
              client2.on('authenticated', () => resolve());
            });

            // Setup notification listeners
            const notifications1: any[] = [];
            const notifications2: any[] = [];

            client1.on('notification', (notification: any) => {
              notifications1.push(notification);
            });

            client2.on('notification', (notification: any) => {
              notifications2.push(notification);
            });

            // Send notification to room 1 only
            await wsService.sendDeploymentNotification(roomId1, deploymentUrl, codeCid);

            // Wait for messages
            await new Promise(resolve => setTimeout(resolve, 200));

            // Property: Only client in room 1 should receive notification
            expect(notifications1.length).toBe(1);
            expect(notifications2.length).toBe(0);

            // Cleanup
            client1.disconnect();
            client2.disconnect();
          }
        ),
        { numRuns: 10 }
      );
    }, 60000);

    it('should include all required fields in deployment notification', async () => {
      await fc.assert(
        fc.asyncProperty(
          fc.record({
            roomId: fc.string({ minLength: 5, maxLength: 50 }),
            deploymentUrl: fc.webUrl(),
            codeCid: fc.string({ minLength: 59, maxLength: 59 }).map(s => 'bafy' + s),
          }),
          async ({ roomId, deploymentUrl, codeCid }) => {
            const client = ioClient(`http://localhost:${serverPort}`, {
              transports: ['websocket'],
            });

            await new Promise<void>((resolve) => {
              client.on('connect', () => resolve());
            });

            client.emit('authenticate', { roomId });

            await new Promise<void>((resolve) => {
              client.on('authenticated', () => resolve());
            });

            const receivedNotifications: any[] = [];
            client.on('notification', (notification: any) => {
              receivedNotifications.push(notification);
            });

            await wsService.sendDeploymentNotification(roomId, deploymentUrl, codeCid);

            await new Promise(resolve => setTimeout(resolve, 100));

            // Property: Notification should have all required fields
            expect(receivedNotifications.length).toBe(1);
            const notification = receivedNotifications[0];

            expect(notification).toHaveProperty('type');
            expect(notification).toHaveProperty('roomId');
            expect(notification).toHaveProperty('deploymentUrl');
            expect(notification).toHaveProperty('codeCid');
            expect(notification).toHaveProperty('timestamp');

            // Property: All fields should have correct types
            expect(typeof notification.type).toBe('string');
            expect(typeof notification.roomId).toBe('string');
            expect(typeof notification.deploymentUrl).toBe('string');
            expect(typeof notification.codeCid).toBe('string');
            expect(notification.timestamp).toBeDefined();

            client.disconnect();
          }
        ),
        { numRuns: 20 }
      );
    }, 60000);
  });
});
