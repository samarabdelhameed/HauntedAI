// Generated by Kiro - Story generation service using Groq (FREE!)
import Groq from 'groq-sdk';
import { StoryGenerationRequest, StoryGenerationResponse } from './types';
import { StorachaClient } from './storacha.client';

export class StoryService {
  private groq: Groq;
  private storacha: StorachaClient;
  private readonly model = 'llama-3.3-70b-versatile'; // Groq's fast and free model
  private readonly maxRetries = 3;
  private readonly initialDelay = 2000; // 2 seconds
  private readonly backoffMultiplier = 2;

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('Groq API key is required');
    }
    this.groq = new Groq({ apiKey });
    this.storacha = new StorachaClient();
  }

  /**
   * Generate a spooky story based on user input with retry logic
   * @param request - Story generation request with user input
   * @returns Generated story with metadata and CID
   */
  async generateStory(request: StoryGenerationRequest): Promise<StoryGenerationResponse> {
    const { input, roomId } = request;

    // Validate input
    if (!input || input.trim().length === 0) {
      throw new Error('Input cannot be empty');
    }

    // Generate story with retry logic
    const story = await this.executeWithRetry(async () => {
      // Create spooky system prompt
      const systemPrompt = this.createSpookySystemPrompt();

      // Call Groq API (FREE and FAST!)
      console.log('Calling Groq API to generate story...');
      const completion = await this.groq.chat.completions.create({
        model: this.model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: input },
        ],
        temperature: 0.9, // Higher temperature for more creative stories
        max_tokens: 1000,
      });

      const generatedStory = completion.choices[0]?.message?.content;

      if (!generatedStory) {
        throw new Error('Failed to generate story: No content returned from Groq');
      }

      console.log(`Story generated successfully (${generatedStory.length} characters)`);
      return generatedStory;
    });

    // Upload story to Storacha
    console.log('Uploading story to Storacha...');
    const filename = `story-${roomId || Date.now()}.txt`;
    const cid = await this.storacha.uploadFile(Buffer.from(story, 'utf-8'), filename);

    console.log(`Story uploaded to Storacha with CID: ${cid}`);

    // Calculate word count
    const wordCount = story.split(/\s+/).filter((word) => word.length > 0).length;

    return {
      story,
      cid,
      metadata: {
        wordCount,
        generatedAt: new Date(),
        model: this.model,
      },
    };
  }

  /**
   * Create a spooky system prompt for story generation
   * @returns System prompt string
   */
  private createSpookySystemPrompt(): string {
    return `You are a master storyteller specializing in spooky, haunting tales. 
Your stories should be:
- Atmospheric and eerie, creating a sense of dread and suspense
- Rich in dark imagery (fog, shadows, moonlight, abandoned places)
- Featuring supernatural elements (ghosts, spirits, haunted objects)
- Written in a gothic, literary style
- Between 200-400 words in length
- Ending with a chilling twist or unsettling revelation

Use vivid descriptions and sensory details to immerse the reader in the haunting atmosphere.
Make every word count to build tension and fear.`;
  }

  /**
   * Check if Groq API is accessible
   * @returns True if API is accessible
   */
  async checkHealth(): Promise<boolean> {
    try {
      // Make a minimal API call to check connectivity
      await this.groq.models.list();
      return true;
    } catch (error) {
      console.error('Groq health check failed:', error);
      return false;
    }
  }

  /**
   * Execute operation with exponential backoff retry logic
   * Requirement 1.4: Retry up to 3 times with exponential backoff
   * @param operation - Async operation to execute
   * @returns Result of the operation
   */
  private async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;

        // Check if error is retryable
        const isRetryable = this.isRetryableError(error);

        if (!isRetryable || attempt >= this.maxRetries - 1) {
          console.error(
            `Operation failed after ${attempt + 1} attempt(s): ${lastError.message}`
          );
          throw lastError;
        }

        // Calculate delay with exponential backoff
        const delay = Math.min(
          this.initialDelay * Math.pow(this.backoffMultiplier, attempt),
          30000 // Max 30 seconds
        );

        console.warn(
          `Operation failed (attempt ${attempt + 1}/${this.maxRetries}), ` +
            `retrying in ${delay}ms: ${lastError.message}`
        );

        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  /**
   * Check if an error is retryable
   * @param error - Error to check
   * @returns True if error is retryable
   */
  private isRetryableError(error: any): boolean {
    // Retry on rate limit errors
    if (error?.status === 429) {
      return true;
    }

    // Retry on timeout errors
    if (error?.code === 'ETIMEDOUT' || error?.code === 'ECONNRESET') {
      return true;
    }

    // Retry on server errors (5xx)
    if (error?.status >= 500 && error?.status < 600) {
      return true;
    }

    // Don't retry on client errors (4xx) except rate limits
    if (error?.status >= 400 && error?.status < 500) {
      return false;
    }

    // Retry on network errors
    if (error?.message?.includes('network') || error?.message?.includes('timeout')) {
      return true;
    }

    // Default to retrying
    return true;
  }

  /**
   * Sleep utility for retry delays
   * @param ms - Milliseconds to sleep
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
