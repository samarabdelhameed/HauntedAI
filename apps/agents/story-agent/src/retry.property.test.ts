// Feature: haunted-ai, Property 4: Story generation retry with backoff
// Validates: Requirements 1.4
// Generated by Kiro - Property-based tests for retry logic

import fc from 'fast-check';
import { StoryService } from './story.service';
import OpenAI from 'openai';

// Mock the Storacha client to avoid ESM issues
jest.mock('./storacha.client', () => {
  return {
    StorachaClient: jest.fn().mockImplementation(() => {
      return {
        uploadFile: jest.fn().mockResolvedValue('bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi'),
        validateCID: jest.fn().mockReturnValue(true),
        initialize: jest.fn().mockResolvedValue(undefined),
      };
    }),
  };
});

describe('Property 4: Story generation retry with backoff', () => {
  let storyService: StoryService;
  let mockOpenAI: jest.Mocked<OpenAI>;

  beforeEach(() => {
    // Create a mock OpenAI instance
    const apiKey = 'test-api-key';
    storyService = new StoryService(apiKey);

    // Mock the OpenAI client
    mockOpenAI = (storyService as any).openai as jest.Mocked<OpenAI>;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should retry up to 3 times with exponential backoff on retryable errors', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.string({ minLength: 1, maxLength: 100 }).filter((s) => s.trim().length > 0),
        async (userInput) => {
          jest.clearAllMocks();

          let attemptCount = 0;
          const delays: number[] = [];
          let lastCallTime = Date.now();

          // Mock OpenAI to fail twice, then succeed
          mockOpenAI.chat = {
            completions: {
              create: jest.fn().mockImplementation(async () => {
                attemptCount++;

                // Record delay between attempts
                if (attemptCount > 1) {
                  const currentTime = Date.now();
                  delays.push(currentTime - lastCallTime);
                }
                lastCallTime = Date.now();

                if (attemptCount < 3) {
                  // Simulate rate limit error (retryable)
                  const error: any = new Error('Rate limit exceeded');
                  error.status = 429;
                  throw error;
                }

                // Third attempt succeeds
                return {
                  choices: [
                    {
                      message: {
                        content: 'A spooky story about ghosts and haunted places.',
                      },
                    },
                  ],
                };
              }),
            },
          } as any;

          // Execute story generation
          const response = await storyService.generateStory({ input: userInput });

          // Property 4: Should retry exactly 3 times (2 failures + 1 success)
          expect(attemptCount).toBe(3);

          // Property 4: Should eventually succeed
          expect(response.story).toBeDefined();
          expect(response.story.length).toBeGreaterThan(0);

          // Property 4: Delays should follow exponential backoff pattern
          // First retry: ~2000ms, Second retry: ~4000ms
          if (delays.length >= 1) {
            expect(delays[0]).toBeGreaterThanOrEqual(1800); // Allow some variance
            expect(delays[0]).toBeLessThanOrEqual(2500);
          }
          if (delays.length >= 2) {
            expect(delays[1]).toBeGreaterThanOrEqual(3800);
            expect(delays[1]).toBeLessThanOrEqual(4500);
          }
        }
      ),
      {
        numRuns: 5,
        timeout: 30000,
      }
    );
  }, 180000);

  it('should fail after 3 attempts if all retries fail', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.string({ minLength: 1, maxLength: 100 }).filter((s) => s.trim().length > 0),
        async (userInput) => {
          jest.clearAllMocks();

          let attemptCount = 0;

          // Mock OpenAI to always fail
          mockOpenAI.chat = {
            completions: {
              create: jest.fn().mockImplementation(async () => {
                attemptCount++;
                const error: any = new Error('Service unavailable');
                error.status = 503;
                throw error;
              }),
            },
          } as any;

          // Property 4: Should throw error after 3 attempts
          await expect(storyService.generateStory({ input: userInput })).rejects.toThrow(
            'Service unavailable'
          );

          // Property 4: Should have attempted exactly 3 times
          expect(attemptCount).toBe(3);
        }
      ),
      {
        numRuns: 5,
        timeout: 30000,
      }
    );
  }, 180000);

  it('should not retry on non-retryable errors (4xx client errors)', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.string({ minLength: 1, maxLength: 100 }).filter((s) => s.trim().length > 0),
        async (userInput) => {
          jest.clearAllMocks();

          let attemptCount = 0;

          // Mock OpenAI to return client error (non-retryable)
          mockOpenAI.chat = {
            completions: {
              create: jest.fn().mockImplementation(async () => {
                attemptCount++;
                const error: any = new Error('Invalid request');
                error.status = 400;
                throw error;
              }),
            },
          } as any;

          // Property 4: Should throw error immediately without retries
          await expect(storyService.generateStory({ input: userInput })).rejects.toThrow(
            'Invalid request'
          );

          // Property 4: Should have attempted only once (no retries for 4xx)
          expect(attemptCount).toBe(1);
        }
      ),
      {
        numRuns: 5,
        timeout: 10000,
      }
    );
  }, 60000);

  it('should handle timeout errors with retry', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.string({ minLength: 1, maxLength: 100 }).filter((s) => s.trim().length > 0),
        async (userInput) => {
          jest.clearAllMocks();

          let attemptCount = 0;

          // Mock OpenAI to timeout once, then succeed
          mockOpenAI.chat = {
            completions: {
              create: jest.fn().mockImplementation(async () => {
                attemptCount++;

                if (attemptCount < 2) {
                  const error: any = new Error('Request timeout');
                  error.code = 'ETIMEDOUT';
                  throw error;
                }

                return {
                  choices: [
                    {
                      message: {
                        content: 'A spooky story about ghosts.',
                      },
                    },
                  ],
                };
              }),
            },
          } as any;

          // Execute story generation
          const response = await storyService.generateStory({ input: userInput });

          // Property 4: Should retry on timeout and eventually succeed
          expect(attemptCount).toBe(2);
          expect(response.story).toBeDefined();
        }
      ),
      {
        numRuns: 5,
        timeout: 20000,
      }
    );
  }, 120000);
});
