// Feature: haunted-ai, Property 1: Non-empty input generates story
// Validates: Requirements 1.1
// Generated by Kiro - Property-based tests for story generation

import fc from 'fast-check';
import { StoryService } from './story.service';

describe('Property 1: Non-empty input generates story', () => {
  let storyService: StoryService;

  beforeAll(() => {
    // Use real OpenAI API key from environment
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY environment variable is required for property tests');
    }
    storyService = new StoryService(apiKey);
  });

  it('should generate non-empty story with spooky elements for any non-empty input', async () => {
    await fc.assert(
      fc.asyncProperty(
        // Generate non-empty strings with reasonable length
        fc.string({ minLength: 1, maxLength: 100 }).filter((s) => s.trim().length > 0),
        async (userInput) => {
          // Reset any state between iterations
          jest.clearAllMocks();

          // Generate story
          const response = await storyService.generateStory({ input: userInput });

          // Property 1: Story should be non-empty
          expect(response.story).toBeDefined();
          expect(response.story.length).toBeGreaterThan(0);
          expect(response.story.trim().length).toBeGreaterThan(0);

          // Property 1: Story should contain spooky elements
          const spookyKeywords = [
            'spooky',
            'ghost',
            'haunted',
            'dark',
            'scary',
            'eerie',
            'shadow',
            'whisper',
            'chill',
            'dread',
            'fear',
            'terror',
            'spirit',
            'phantom',
            'specter',
            'fog',
            'mist',
            'moonlight',
            'abandoned',
            'creep',
            'sinister',
            'ominous',
            'macabre',
            'grim',
            'pale',
            'cold',
            'death',
            'grave',
            'tomb',
            'night',
          ];

          const storyLower = response.story.toLowerCase();
          const hasSpookyElement = spookyKeywords.some((keyword) =>
            storyLower.includes(keyword)
          );

          expect(hasSpookyElement).toBe(true);

          // Verify metadata
          expect(response.metadata).toBeDefined();
          expect(response.metadata.wordCount).toBeGreaterThan(0);
          expect(response.metadata.generatedAt).toBeInstanceOf(Date);
          expect(response.metadata.model).toBe('gpt-4');
        }
      ),
      {
        numRuns: 5, // Reduced from 100 due to API costs and rate limits
        timeout: 30000, // 30 second timeout per test
      }
    );
  }, 180000); // 3 minute timeout for entire test

  it('should reject empty or whitespace-only input', async () => {
    await fc.assert(
      fc.asyncProperty(
        // Generate whitespace strings
        fc.constantFrom('', '   ', '\n', '\t', '  \n\t  '),
        async (emptyInput) => {
          // Should throw error for empty input
          await expect(storyService.generateStory({ input: emptyInput })).rejects.toThrow(
            'Input cannot be empty'
          );
        }
      ),
      { numRuns: 10 }
    );
  });

  it('should handle various input lengths', async () => {
    await fc.assert(
      fc.asyncProperty(
        // Generate strings of varying lengths
        fc.oneof(
          fc.string({ minLength: 1, maxLength: 10 }),
          fc.string({ minLength: 10, maxLength: 50 }),
          fc.string({ minLength: 50, maxLength: 200 })
        ).filter((s) => s.trim().length > 0),
        async (userInput) => {
          const response = await storyService.generateStory({ input: userInput });

          // Should generate story regardless of input length
          expect(response.story.length).toBeGreaterThan(0);
          expect(response.metadata.wordCount).toBeGreaterThan(0);
        }
      ),
      {
        numRuns: 3, // Reduced due to API costs
        timeout: 30000,
      }
    );
  }, 120000);
});
