// Generated by Kiro - Asset generation service using OpenAI DALL-E 3
import OpenAI from 'openai';
import axios from 'axios';
import sharp from 'sharp';
import { AssetGenerationRequest, AssetGenerationResponse } from './types';
import { StorachaClient } from './storacha.client';

export class AssetService {
  private openai: OpenAI;
  private storacha: StorachaClient;
  private readonly model = 'dall-e-3';
  private readonly maxRetries = 3;
  private readonly initialDelay = 2000; // 2 seconds
  private readonly backoffMultiplier = 2;
  private readonly maxImageSize = 1024 * 1024; // 1MB

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error('OpenAI API key is required');
    }
    this.openai = new OpenAI({ apiKey });
    this.storacha = new StorachaClient();
  }

  /**
   * Generate a spooky image based on story with retry logic
   * Requirement 2.1: Generate image from story summary
   * @param request - Asset generation request with story
   * @returns Generated image CID and metadata
   */
  async generateAsset(request: AssetGenerationRequest): Promise<AssetGenerationResponse> {
    const { story, storySummary, roomId } = request;

    // Validate input
    if (!story || story.trim().length === 0) {
      throw new Error('Story cannot be empty');
    }

    // Generate image prompt from story
    const imagePrompt = await this.generateImagePrompt(storySummary || story);
    console.log(`Generated image prompt: "${imagePrompt.substring(0, 100)}..."`);

    // Generate image with retry logic
    const { imageBuffer, imageUrl } = await this.executeWithRetry(async () => {
      console.log('Calling DALL-E 3 API to generate image...');
      
      const response = await this.openai.images.generate({
        model: this.model,
        prompt: imagePrompt,
        n: 1,
        size: '1024x1024',
        quality: 'standard',
        style: 'vivid', // More dramatic and spooky
      });

      const generatedImageUrl = response.data?.[0]?.url;

      if (!generatedImageUrl) {
        throw new Error('Failed to generate image: No URL returned from DALL-E');
      }

      console.log(`Image generated successfully: ${generatedImageUrl}`);

      // Download the image
      console.log('Downloading generated image...');
      const imageResponse = await axios.get(generatedImageUrl, {
        responseType: 'arraybuffer',
        timeout: 30000,
      });

      const imageBuffer = Buffer.from(imageResponse.data);
      console.log(`Image downloaded (${imageBuffer.length} bytes)`);

      return { imageBuffer, imageUrl: generatedImageUrl };
    });

    // Optimize image if larger than 1MB
    let optimizedBuffer = imageBuffer;
    let metadata = await sharp(imageBuffer).metadata();

    if (imageBuffer.length > this.maxImageSize) {
      console.log(`Image size (${imageBuffer.length} bytes) exceeds ${this.maxImageSize} bytes, optimizing...`);
      optimizedBuffer = await this.optimizeImage(imageBuffer);
      metadata = await sharp(optimizedBuffer).metadata();
      console.log(`Image optimized to ${optimizedBuffer.length} bytes`);
    }

    // Upload image to Storacha
    console.log('Uploading image to Storacha...');
    const filename = `image-${roomId || Date.now()}.png`;
    const imageCid = await this.storacha.uploadFile(optimizedBuffer, filename, 'image/png');

    console.log(`Image uploaded to Storacha with CID: ${imageCid}`);

    return {
      imageCid,
      imageUrl,
      metadata: {
        size: optimizedBuffer.length,
        format: metadata.format || 'png',
        width: metadata.width || 1024,
        height: metadata.height || 1024,
        generatedAt: new Date(),
        model: this.model,
        prompt: imagePrompt,
      },
    };
  }

  /**
   * Generate an image prompt from story summary
   * Requirement 2.1: Generate image prompt from story
   * @param story - Story text or summary
   * @returns Image prompt for DALL-E
   */
  private async generateImagePrompt(story: string): Promise<string> {
    // Extract key themes and create a spooky image prompt
    const summaryPrompt = `Based on this spooky story, create a brief image description (max 100 words) that captures the most haunting visual scene. Focus on atmosphere, setting, and key supernatural elements:\n\n${story.substring(0, 1000)}`;

    try {
      const completion = await this.openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: 'You are an expert at creating vivid, atmospheric image descriptions for horror and gothic art. Create concise, visual descriptions that emphasize mood, lighting, and supernatural elements.',
          },
          { role: 'user', content: summaryPrompt },
        ],
        temperature: 0.8,
        max_tokens: 150,
      });

      const description = completion.choices[0]?.message?.content || '';

      // Enhance with spooky style parameters
      return `${description}. Dark gothic horror style, dramatic lighting, fog and shadows, eerie atmosphere, cinematic composition, highly detailed, photorealistic`;
    } catch (error) {
      console.warn('Failed to generate custom prompt, using fallback:', error);
      // Fallback: Extract first sentence and add spooky styling
      const firstSentence = story.split('.')[0] || story.substring(0, 200);
      return `${firstSentence}. Dark gothic horror style, dramatic lighting, fog and shadows, eerie atmosphere, cinematic composition, highly detailed, photorealistic`;
    }
  }

  /**
   * Optimize image size by compressing
   * Requirement 2.1: Optimize image size (compress if > 1MB)
   * @param imageBuffer - Original image buffer
   * @returns Optimized image buffer
   */
  private async optimizeImage(imageBuffer: Buffer): Promise<Buffer> {
    return await sharp(imageBuffer)
      .png({
        quality: 80,
        compressionLevel: 9,
      })
      .toBuffer();
  }

  /**
   * Check if OpenAI API is accessible
   * @returns True if API is accessible
   */
  async checkHealth(): Promise<boolean> {
    try {
      // Make a minimal API call to check connectivity
      await this.openai.models.list();
      return true;
    } catch (error) {
      console.error('OpenAI health check failed:', error);
      return false;
    }
  }

  /**
   * Execute operation with exponential backoff retry logic
   * Requirement 2.4: Retry up to 3 times with exponential backoff
   * @param operation - Async operation to execute
   * @returns Result of the operation
   */
  private async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;

        // Check if error is retryable
        const isRetryable = this.isRetryableError(error);

        if (!isRetryable || attempt >= this.maxRetries - 1) {
          console.error(
            `Operation failed after ${attempt + 1} attempt(s): ${lastError.message}`
          );
          throw lastError;
        }

        // Calculate delay with exponential backoff
        const delay = Math.min(
          this.initialDelay * Math.pow(this.backoffMultiplier, attempt),
          30000 // Max 30 seconds
        );

        console.warn(
          `Operation failed (attempt ${attempt + 1}/${this.maxRetries}), ` +
            `retrying in ${delay}ms: ${lastError.message}`
        );

        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  /**
   * Check if an error is retryable
   * @param error - Error to check
   * @returns True if error is retryable
   */
  private isRetryableError(error: any): boolean {
    // Retry on rate limit errors
    if (error?.status === 429) {
      return true;
    }

    // Retry on timeout errors
    if (error?.code === 'ETIMEDOUT' || error?.code === 'ECONNRESET') {
      return true;
    }

    // Retry on server errors (5xx)
    if (error?.status >= 500 && error?.status < 600) {
      return true;
    }

    // Don't retry on client errors (4xx) except rate limits
    if (error?.status >= 400 && error?.status < 500) {
      return false;
    }

    // Retry on network errors
    if (error?.message?.includes('network') || error?.message?.includes('timeout')) {
      return true;
    }

    // Default to retrying
    return true;
  }

  /**
   * Sleep utility for retry delays
   * @param ms - Milliseconds to sleep
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
