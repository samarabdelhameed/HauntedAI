// Generated by Kiro - Asset generation service using Pollination AI (FREE)
// Ø§Ù„Ø¨Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ - Ù„Ø§ ÙŠØ­ØªØ§Ø¬ API key
import axios from 'axios';
import sharp from 'sharp';
import { AssetGenerationRequest, AssetGenerationResponse } from './types';
import { StorachaClient } from './storacha.client';

export class AssetService {
  private storacha: StorachaClient;
  private readonly pollinationBaseUrl = 'https://image.pollinations.ai/prompt';
  private readonly maxRetries = 3;
  private readonly initialDelay = 2000; // 2 seconds
  private readonly backoffMultiplier = 2;
  private readonly maxImageSize = 1024 * 1024; // 1MB

  constructor(apiKey?: string) {
    // API key is optional now - Pollination AI doesn't need it!
    console.log('âœ¨ Using Pollination AI - FREE image generation (no API key needed)');
    this.storacha = new StorachaClient();
  }

  /**
   * Generate a spooky image based on story with retry logic
   * Requirement 2.1: Generate image from story summary
   * @param request - Asset generation request with story
   * @returns Generated image CID and metadata
   */
  async generateAsset(request: AssetGenerationRequest): Promise<AssetGenerationResponse> {
    const { story, storySummary, roomId } = request;

    // Validate input
    if (!story || story.trim().length === 0) {
      throw new Error('Story cannot be empty');
    }

    // Generate image prompt from story
    const imagePrompt = await this.generateImagePrompt(storySummary || story);
    console.log(`Generated image prompt: "${imagePrompt.substring(0, 100)}..."`);

    // Generate image with retry logic using Pollination AI
    const { imageBuffer, imageUrl } = await this.executeWithRetry(async () => {
      console.log('ðŸŽ¨ Calling Pollination AI (FREE) to generate image...');
      
      // Build Pollination AI URL - no API key needed!
      const generatedImageUrl = `${this.pollinationBaseUrl}/${encodeURIComponent(imagePrompt)}&width=1024&height=1024&nologo=true&enhance=true&model=flux`;

      console.log(`Image URL generated: ${generatedImageUrl.substring(0, 100)}...`);

      // Download the image directly
      console.log('Downloading generated image from Pollination AI...');
      const imageResponse = await axios.get(generatedImageUrl, {
        responseType: 'arraybuffer',
        timeout: 30000,
      });

      const imageBuffer = Buffer.from(imageResponse.data);
      console.log(`âœ… Image downloaded successfully (${imageBuffer.length} bytes)`);

      return { imageBuffer, imageUrl: generatedImageUrl };
    });

    // Optimize image if larger than 1MB
    let optimizedBuffer = imageBuffer;
    let metadata = await sharp(imageBuffer).metadata();

    if (imageBuffer.length > this.maxImageSize) {
      console.log(`Image size (${imageBuffer.length} bytes) exceeds ${this.maxImageSize} bytes, optimizing...`);
      optimizedBuffer = await this.optimizeImage(imageBuffer);
      metadata = await sharp(optimizedBuffer).metadata();
      console.log(`Image optimized to ${optimizedBuffer.length} bytes`);
    }

    // Upload image to Storacha
    console.log('Uploading image to Storacha...');
    const filename = `image-${roomId || Date.now()}.png`;
    const imageCid = await this.storacha.uploadFile(optimizedBuffer, filename, 'image/png');

    console.log(`Image uploaded to Storacha with CID: ${imageCid}`);

    return {
      imageCid,
      imageUrl,
      metadata: {
        size: optimizedBuffer.length,
        format: metadata.format || 'png',
        width: metadata.width || 1024,
        height: metadata.height || 1024,
        generatedAt: new Date(),
        model: 'pollination-ai-flux',
        provider: 'Pollination AI (FREE)',
        prompt: imagePrompt,
      },
    };
  }

  /**
   * Generate an image prompt from story summary
   * Requirement 2.1: Generate image prompt from story
   * @param story - Story text or summary
   * @returns Image prompt for Pollination AI
   */
  private async generateImagePrompt(story: string): Promise<string> {
    // Extract key themes and create a spooky image prompt
    // Since we don't have OpenAI for prompt generation, we'll create a good prompt directly
    
    // Extract first meaningful sentence or key phrases
    const sentences = story.split(/[.!?]+/).filter(s => s.trim().length > 20);
    const keyPhrase = sentences[0] || story.substring(0, 200);
    
    // Create enhanced spooky prompt for Pollination AI
    const enhancedPrompt = `${keyPhrase.trim()}. Dark gothic horror style, haunted atmosphere, dramatic cinematic lighting, deep shadows and fog, eerie supernatural elements, photorealistic, highly detailed, 4k quality, spooky Halloween theme`;
    
    console.log(`ðŸ“ Generated prompt: "${enhancedPrompt.substring(0, 100)}..."`);
    
    return enhancedPrompt;
  }

  /**
   * Optimize image size by compressing
   * Requirement 2.1: Optimize image size (compress if > 1MB)
   * @param imageBuffer - Original image buffer
   * @returns Optimized image buffer
   */
  private async optimizeImage(imageBuffer: Buffer): Promise<Buffer> {
    return await sharp(imageBuffer)
      .png({
        quality: 80,
        compressionLevel: 9,
      })
      .toBuffer();
  }

  /**
   * Check if Pollination AI is accessible
   * @returns True if API is accessible
   */
  async checkHealth(): Promise<boolean> {
    try {
      // Test with a simple request
      const testUrl = `${this.pollinationBaseUrl}/test&width=256&height=256`;
      const response = await axios.head(testUrl, { timeout: 5000 });
      return response.status === 200;
    } catch (error) {
      console.error('Pollination AI health check failed:', error);
      // Pollination AI is usually always available, so return true
      return true;
    }
  }

  /**
   * Execute operation with exponential backoff retry logic
   * Requirement 2.4: Retry up to 3 times with exponential backoff
   * @param operation - Async operation to execute
   * @returns Result of the operation
   */
  private async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;

        // Check if error is retryable
        const isRetryable = this.isRetryableError(error);

        if (!isRetryable || attempt >= this.maxRetries - 1) {
          console.error(
            `Operation failed after ${attempt + 1} attempt(s): ${lastError.message}`
          );
          throw lastError;
        }

        // Calculate delay with exponential backoff
        const delay = Math.min(
          this.initialDelay * Math.pow(this.backoffMultiplier, attempt),
          30000 // Max 30 seconds
        );

        console.warn(
          `Operation failed (attempt ${attempt + 1}/${this.maxRetries}), ` +
            `retrying in ${delay}ms: ${lastError.message}`
        );

        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  /**
   * Check if an error is retryable
   * @param error - Error to check
   * @returns True if error is retryable
   */
  private isRetryableError(error: any): boolean {
    // Retry on rate limit errors
    if (error?.status === 429) {
      return true;
    }

    // Retry on timeout errors
    if (error?.code === 'ETIMEDOUT' || error?.code === 'ECONNRESET') {
      return true;
    }

    // Retry on server errors (5xx)
    if (error?.status >= 500 && error?.status < 600) {
      return true;
    }

    // Don't retry on client errors (4xx) except rate limits
    if (error?.status >= 400 && error?.status < 500) {
      return false;
    }

    // Retry on network errors
    if (error?.message?.includes('network') || error?.message?.includes('timeout')) {
      return true;
    }

    // Default to retrying
    return true;
  }

  /**
   * Sleep utility for retry delays
   * @param ms - Milliseconds to sleep
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
