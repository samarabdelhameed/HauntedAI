// Generated by Kiro - CodeAgent Service
import { GoogleGenerativeAI } from '@google/generative-ai';
import { StorachaClient } from './storacha.client';
import {
  CodeGenerationRequest,
  CodeGenerationResponse,
  CodeTestResult,
  CodePatchRequest,
  CodePatchResponse,
} from './types';

export class CodeService {
  private genAI: GoogleGenerativeAI;
  private model: any;
  private storachaClient: StorachaClient;
  private readonly maxPatchAttempts = 3;

  constructor() {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY environment variable is required');
    }

    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-1.5-pro' });
    this.storachaClient = new StorachaClient();
  }

  /**
   * Generate mini-game code based on story and image theme
   */
  async generateCode(request: CodeGenerationRequest): Promise<CodeGenerationResponse> {
    console.log('Starting code generation...');
    console.log(`Story: ${request.story.substring(0, 100)}...`);
    console.log(`Image Theme: ${request.imageTheme}`);

    // Generate initial code
    let code = await this.callGeminiForCode(request.story, request.imageTheme);
    let patchAttempts = 0;

    // Test and patch loop
    for (let attempt = 0; attempt < this.maxPatchAttempts; attempt++) {
      const testResult = await this.testCode(code);

      if (testResult.passed) {
        console.log('Code passed all tests!');
        break;
      }

      console.log(`Code failed tests (attempt ${attempt + 1}/${this.maxPatchAttempts})`);
      console.log('Errors:', testResult.errors);

      if (attempt < this.maxPatchAttempts - 1) {
        // Generate patch
        const patchResponse = await this.generatePatch({
          code,
          errors: testResult.errors,
        });

        code = patchResponse.patchedCode;
        patchAttempts++;
        console.log(`Applied patch (attempt ${patchAttempts})`);
      } else {
        console.warn('Max patch attempts reached, proceeding with current code');
      }
    }

    // Upload to Storacha
    console.log('Uploading code to Storacha...');
    const cid = await this.storachaClient.uploadFile(Buffer.from(code), 'game.html');

    return {
      code,
      cid,
      tested: true,
      patchAttempts,
    };
  }

  /**
   * Call Google Gemini API to generate mini-game code
   */
  private async callGeminiForCode(story: string, imageTheme: string): Promise<string> {
    const systemPrompt = `You are a creative game developer who creates spooky mini-games in HTML/JavaScript.
Generate a complete, self-contained HTML file with embedded CSS and JavaScript.
The game should be simple, interactive, and themed around the provided story.
Use only vanilla JavaScript (no external libraries).
Ensure the code is secure (no eval, no inline event handlers).
Make it visually appealing with dark, spooky aesthetics.`;

    const userPrompt = this.buildCodePrompt(story, imageTheme);
    const fullPrompt = `${systemPrompt}\n\n${userPrompt}`;

    console.log('Calling Google Gemini API for code generation...');

    const result = await this.model.generateContent(fullPrompt);
    const response = await result.response;
    const generatedCode = response.text();

    if (!generatedCode) {
      throw new Error('Gemini API returned empty response');
    }

    // Extract code from markdown if present
    const codeMatch = generatedCode.match(/```html\n([\s\S]*?)\n```/);
    const code = codeMatch ? codeMatch[1] : generatedCode;

    console.log(`Generated code (${code.length} characters)`);

    return code;
  }

  /**
   * Build prompt for code generation
   */
  private buildCodePrompt(story: string, imageTheme: string): string {
    return `Create a spooky mini-game based on this story and theme:

Story: ${story}

Image Theme: ${imageTheme}

Requirements:
1. Create a complete HTML file with embedded CSS and JavaScript
2. The game should be simple and playable (e.g., click game, avoid game, collect game)
3. Use dark, spooky colors (blacks, purples, reds)
4. Add spooky sound effects or visual effects
5. Include a score or progress indicator
6. Make it responsive and work on mobile
7. NO external libraries - only vanilla JavaScript
8. NO eval() or similar dangerous functions
9. NO inline event handlers (use addEventListener)
10. Include clear instructions for the player

Generate ONLY the HTML code, nothing else.`;
  }

  /**
   * Test generated code for errors and security issues
   */
  async testCode(code: string): Promise<CodeTestResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Basic syntax validation
    try {
      // Check for dangerous patterns
      if (code.includes('eval(')) {
        errors.push('Code contains eval() which is a security risk');
      }

      if (code.includes('Function(')) {
        errors.push('Code contains Function() constructor which is a security risk');
      }

      if (code.match(/on\w+\s*=/)) {
        errors.push('Code contains inline event handlers (use addEventListener instead)');
      }

      // Check for basic HTML structure
      if (!code.includes('<html') && !code.includes('<!DOCTYPE')) {
        warnings.push('Code may be missing HTML document structure');
      }

      // Check for script tags
      const scriptMatches = code.match(/<script>([\s\S]*?)<\/script>/g);
      if (!scriptMatches || scriptMatches.length === 0) {
        warnings.push('Code may be missing JavaScript functionality');
      }

      // Basic JavaScript syntax checks
      if (scriptMatches) {
        for (const scriptTag of scriptMatches) {
          const jsCode = scriptTag.replace(/<\/?script>/g, '');
          
          // Check for basic syntax issues
          if (jsCode.includes('var ')) {
            warnings.push('Consider using let/const instead of var');
          }
          
          // Check for console.log (should be removed in production)
          if (jsCode.includes('console.log')) {
            warnings.push('Code contains console.log statements');
          }
        }
      }
    } catch (error) {
      errors.push(`Validation error: ${(error as Error).message}`);
    }

    return {
      passed: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Generate patch for failed code
   */
  async generatePatch(request: CodePatchRequest): Promise<CodePatchResponse> {
    console.log('Generating patch for failed code...');

    const systemPrompt = 'You are a code debugger. Fix the errors in the provided code while maintaining its functionality.';
    
    const userPrompt = `The following HTML/JavaScript code has errors. Please fix them:

ERRORS:
${request.errors.join('\n')}

CODE:
${request.code}

Please provide the corrected code. Generate ONLY the fixed HTML code, nothing else.`;

    const fullPrompt = `${systemPrompt}\n\n${userPrompt}`;

    const result = await this.model.generateContent(fullPrompt);
    const response = await result.response;
    const patchedCode = response.text();

    if (!patchedCode) {
      throw new Error('Gemini API returned empty patch response');
    }

    // Extract code from markdown if present
    const codeMatch = patchedCode.match(/```html\n([\s\S]*?)\n```/);
    const code = codeMatch ? codeMatch[1] : patchedCode;

    return {
      patchedCode: code,
      changes: 'Applied fixes for: ' + request.errors.join(', '),
    };
  }
}
