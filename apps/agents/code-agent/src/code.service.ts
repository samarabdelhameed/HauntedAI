// Generated by Kiro - CodeAgent Service with HuggingFace (FREE!)
import axios from 'axios';
import { StorachaClient } from './storacha.client';
import {
  CodeGenerationRequest,
  CodeGenerationResponse,
  CodeTestResult,
  CodePatchRequest,
  CodePatchResponse,
} from './types';

export class CodeService {
  private apiKey: string;
  private apiUrl: string;
  private storachaClient: StorachaClient;
  private readonly maxPatchAttempts = 3;
  private readonly maxRetries = 5;
  private readonly baseRetryDelay = 1000; // 1 second

  constructor() {
    const apiKey = process.env.HUGGINGFACE_API_KEY;
    if (!apiKey) {
      throw new Error('HUGGINGFACE_API_KEY environment variable is required');
    }

    this.apiKey = apiKey;
    // Using CodeLlama for code generation (FREE - 30k requests/day!)
    this.apiUrl =
      'https://api-inference.huggingface.co/models/codellama/CodeLlama-7b-Instruct-hf';
    this.storachaClient = new StorachaClient();
  }

  /**
   * Generate mini-game code based on story and image theme
   */
  async generateCode(request: CodeGenerationRequest): Promise<CodeGenerationResponse> {
    console.log('Starting code generation...');
    console.log(`Story: ${request.story.substring(0, 100)}...`);
    console.log(`Image Theme: ${request.imageTheme}`);

    // Generate initial code
    let code = await this.callHuggingFaceForCode(request.story, request.imageTheme);
    let patchAttempts = 0;

    // Test and patch loop
    for (let attempt = 0; attempt < this.maxPatchAttempts; attempt++) {
      const testResult = await this.testCode(code);

      if (testResult.passed) {
        console.log('Code passed all tests!');
        break;
      }

      console.log(`Code failed tests (attempt ${attempt + 1}/${this.maxPatchAttempts})`);
      console.log('Errors:', testResult.errors);

      if (attempt < this.maxPatchAttempts - 1) {
        // Generate patch
        const patchResponse = await this.generatePatch({
          code,
          errors: testResult.errors,
        });

        code = patchResponse.patchedCode;
        patchAttempts++;
        console.log(`Applied patch (attempt ${patchAttempts})`);
      } else {
        console.warn('Max patch attempts reached, proceeding with current code');
      }
    }

    // Upload to Storacha
    console.log('Uploading code to Storacha...');
    const cid = await this.storachaClient.uploadFile(Buffer.from(code), 'game.html');

    return {
      code,
      cid,
      tested: true,
      patchAttempts,
    };
  }

  /**
   * Call HuggingFace API to generate mini-game code
   */
  private async callHuggingFaceForCode(story: string, imageTheme: string): Promise<string> {
    const prompt = this.buildCodePrompt(story, imageTheme);

    console.log('Calling HuggingFace API for code generation...');

    let lastError: Error | null = null;

    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        const response = await axios.post(
          this.apiUrl,
          {
            inputs: prompt,
            parameters: {
              max_new_tokens: 2000,
              temperature: 0.7,
              top_p: 0.95,
              return_full_text: false,
            },
          },
          {
            headers: {
              Authorization: `Bearer ${this.apiKey}`,
              'Content-Type': 'application/json',
            },
            timeout: 30000, // 30 seconds
          }
        );

        let generatedCode = '';

        if (Array.isArray(response.data)) {
          generatedCode = response.data[0]?.generated_text || '';
        } else if (response.data.generated_text) {
          generatedCode = response.data.generated_text;
        } else if (typeof response.data === 'string') {
          generatedCode = response.data;
        }

        if (!generatedCode) {
          throw new Error('HuggingFace API returned empty response');
        }

        // Extract code from markdown if present
        const codeMatch = generatedCode.match(/```html\n([\s\S]*?)\n```/);
        const code = codeMatch ? codeMatch[1] : generatedCode;

        console.log(`Generated code (${code.length} characters)`);

        return code;
      } catch (error: any) {
        lastError = error;

        // Check if model is loading
        if (error.response?.status === 503) {
          const estimatedTime = error.response?.data?.estimated_time || 20;
          console.log(
            `Model is loading... Waiting ${estimatedTime}s (attempt ${attempt + 1}/${this.maxRetries})`
          );

          if (attempt < this.maxRetries - 1) {
            await this.sleep(estimatedTime * 1000);
            continue;
          }
        }

        // Check for rate limiting
        if (error.response?.status === 429) {
          const retryDelay = this.baseRetryDelay * Math.pow(2, attempt);
          console.log(`Rate limited. Retrying in ${retryDelay}ms...`);

          if (attempt < this.maxRetries - 1) {
            await this.sleep(retryDelay);
            continue;
          }
        }

        console.error('HuggingFace API error:', error.message);

        if (attempt < this.maxRetries - 1) {
          const retryDelay = this.baseRetryDelay * Math.pow(2, attempt);
          console.log(`Retrying in ${retryDelay}ms...`);
          await this.sleep(retryDelay);
        }
      }
    }

    throw lastError || new Error('Failed to generate code after all retries');
  }

  /**
   * Build prompt for code generation
   */
  private buildCodePrompt(story: string, imageTheme: string): string {
    return `Create a spooky mini-game in HTML with embedded CSS and JavaScript based on this story:

Story: ${story}

Theme: ${imageTheme}

Requirements:
1. Complete HTML file with <!DOCTYPE html>
2. Embedded CSS in <style> tags
3. Embedded JavaScript in <script> tags
4. Simple interactive game (click, avoid, collect)
5. Dark spooky colors (black, purple, red)
6. Score or progress indicator
7. Responsive design
8. NO external libraries
9. NO eval() or dangerous functions
10. NO inline event handlers

Generate ONLY the HTML code:`;
  }

  /**
   * Test generated code for errors and security issues
   */
  async testCode(code: string): Promise<CodeTestResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Basic syntax validation
    try {
      // Check for dangerous patterns
      if (code.includes('eval(')) {
        errors.push('Code contains eval() which is a security risk');
      }

      if (code.includes('Function(')) {
        errors.push('Code contains Function() constructor which is a security risk');
      }

      if (code.match(/on\w+\s*=/)) {
        errors.push('Code contains inline event handlers (use addEventListener instead)');
      }

      // Check for basic HTML structure
      if (!code.includes('<html') && !code.includes('<!DOCTYPE')) {
        warnings.push('Code may be missing HTML document structure');
      }

      // Check for script tags
      const scriptMatches = code.match(/<script>([\s\S]*?)<\/script>/g);
      if (!scriptMatches || scriptMatches.length === 0) {
        warnings.push('Code may be missing JavaScript functionality');
      }

      // Basic JavaScript syntax checks
      if (scriptMatches) {
        for (const scriptTag of scriptMatches) {
          const jsCode = scriptTag.replace(/<\/?script>/g, '');

          // Check for basic syntax issues
          if (jsCode.includes('var ')) {
            warnings.push('Consider using let/const instead of var');
          }

          // Check for console.log (should be removed in production)
          if (jsCode.includes('console.log')) {
            warnings.push('Code contains console.log statements');
          }
        }
      }
    } catch (error) {
      errors.push(`Validation error: ${(error as Error).message}`);
    }

    return {
      passed: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Generate patch for failed code
   */
  async generatePatch(request: CodePatchRequest): Promise<CodePatchResponse> {
    console.log('Generating patch for failed code...');

    const prompt = `Fix the following HTML/JavaScript code errors:

ERRORS:
${request.errors.join('\n')}

CODE:
${request.code}

Provide ONLY the fixed HTML code:`;

    try {
      const response = await axios.post(
        this.apiUrl,
        {
          inputs: prompt,
          parameters: {
            max_new_tokens: 2000,
            temperature: 0.3,
            return_full_text: false,
          },
        },
        {
          headers: {
            Authorization: `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
          },
          timeout: 30000,
        }
      );

      let patchedCode = '';

      if (Array.isArray(response.data)) {
        patchedCode = response.data[0]?.generated_text || '';
      } else if (response.data.generated_text) {
        patchedCode = response.data.generated_text;
      } else if (typeof response.data === 'string') {
        patchedCode = response.data;
      }

      if (!patchedCode) {
        throw new Error('HuggingFace API returned empty patch response');
      }

      // Extract code from markdown if present
      const codeMatch = patchedCode.match(/```html\n([\s\S]*?)\n```/);
      const code = codeMatch ? codeMatch[1] : patchedCode;

      return {
        patchedCode: code,
        changes: 'Applied fixes for: ' + request.errors.join(', '),
      };
    } catch (error) {
      console.error('Patch generation failed:', error);
      // Return original code if patch fails
      return {
        patchedCode: request.code,
        changes: 'Patch generation failed, using original code',
      };
    }
  }

  /**
   * Sleep utility for retry delays
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
