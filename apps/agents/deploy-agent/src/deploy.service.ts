// Generated by Kiro - DeployAgent Service
import axios from 'axios';
import { StorachaClient } from './storacha.client';
import type { DeployRequest, DeployResponse, VercelDeploymentResponse } from './types';

export class DeployService {
  private storachaClient: StorachaClient;
  private vercelToken: string;
  private vercelTeamId?: string;
  private readonly maxRetries = 3;
  private readonly initialDelay = 2000;
  private readonly backoffMultiplier = 2;

  constructor() {
    this.storachaClient = new StorachaClient();
    this.vercelToken = process.env.VERCEL_TOKEN || '';
    this.vercelTeamId = process.env.VERCEL_TEAM_ID;

    if (!this.vercelToken) {
      console.warn('VERCEL_TOKEN not set - deployment will fail');
    }
  }

  /**
   * Deploy code to Vercel
   * @param request - Deployment request with code CID
   * @returns Deployment response with URL
   */
  async deploy(request: DeployRequest): Promise<DeployResponse> {
    try {
      console.log(`Starting deployment for room ${request.roomId} with CID: ${request.codeCid}`);

      // Validate CID format
      if (!this.storachaClient.validateCID(request.codeCid)) {
        throw new Error(`Invalid CID format: ${request.codeCid}`);
      }

      // Step 1: Fetch code from IPFS
      console.log('Fetching code from IPFS...');
      const code = await this.storachaClient.retrieveFile(request.codeCid);

      if (!code || code.trim().length === 0) {
        throw new Error('Retrieved code is empty');
      }

      console.log(`Code retrieved successfully (${code.length} bytes)`);

      // Step 2: Deploy to Vercel with retry logic
      console.log('Deploying to Vercel...');
      const deployment = await this.deployToVercel(code, request);

      console.log(`Deployment successful: ${deployment.url}`);

      return {
        success: true,
        deploymentUrl: `https://${deployment.url}`,
        deploymentId: deployment.id,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error(`Deployment failed: ${errorMessage}`);

      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Deploy code to Vercel with retry logic
   */
  private async deployToVercel(
    code: string,
    request: DeployRequest
  ): Promise<VercelDeploymentResponse> {
    return this.executeWithRetry(async () => {
      const projectName = request.projectName || `haunted-${request.roomId.substring(0, 8)}`;

      // Prepare deployment payload
      const payload = {
        name: projectName,
        files: [
          {
            file: 'index.html',
            data: code,
          },
        ],
        projectSettings: {
          framework: null,
          buildCommand: null,
          outputDirectory: null,
        },
        target: 'production',
      };

      // Build Vercel API URL
      const apiUrl = this.vercelTeamId
        ? `https://api.vercel.com/v13/deployments?teamId=${this.vercelTeamId}`
        : 'https://api.vercel.com/v13/deployments';

      console.log(`Deploying to Vercel API: ${apiUrl}`);

      // Make deployment request
      const response = await axios.post(apiUrl, payload, {
        headers: {
          Authorization: `Bearer ${this.vercelToken}`,
          'Content-Type': 'application/json',
        },
        timeout: 60000, // 60 second timeout
      });

      if (!response.data || !response.data.url) {
        throw new Error('Invalid response from Vercel API');
      }

      console.log(`Vercel deployment created: ${response.data.id}`);

      // Wait for deployment to be ready
      await this.waitForDeployment(response.data.id);

      return {
        id: response.data.id,
        url: response.data.url,
        name: response.data.name,
        readyState: response.data.readyState || 'READY',
      };
    });
  }

  /**
   * Wait for deployment to be ready
   */
  private async waitForDeployment(deploymentId: string): Promise<void> {
    const maxWaitTime = 120000; // 2 minutes
    const pollInterval = 5000; // 5 seconds
    const startTime = Date.now();

    while (Date.now() - startTime < maxWaitTime) {
      try {
        const apiUrl = this.vercelTeamId
          ? `https://api.vercel.com/v13/deployments/${deploymentId}?teamId=${this.vercelTeamId}`
          : `https://api.vercel.com/v13/deployments/${deploymentId}`;

        const response = await axios.get(apiUrl, {
          headers: {
            Authorization: `Bearer ${this.vercelToken}`,
          },
        });

        const state = response.data.readyState || response.data.state;

        console.log(`Deployment state: ${state}`);

        if (state === 'READY') {
          console.log('Deployment is ready');
          return;
        }

        if (state === 'ERROR' || state === 'CANCELED') {
          throw new Error(`Deployment failed with state: ${state}`);
        }

        // Wait before next poll
        await this.sleep(pollInterval);
      } catch (error) {
        if (axios.isAxiosError(error) && error.response?.status === 404) {
          // Deployment might not be immediately available, continue polling
          await this.sleep(pollInterval);
          continue;
        }
        throw error;
      }
    }

    throw new Error('Deployment timeout - exceeded maximum wait time');
  }

  /**
   * Execute operation with exponential backoff retry logic
   */
  private async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;

        // Check if error is retryable
        if (axios.isAxiosError(error)) {
          const status = error.response?.status;
          // Don't retry on client errors (4xx except 429)
          if (status && status >= 400 && status < 500 && status !== 429) {
            console.error(`Non-retryable error (${status}): ${error.message}`);
            throw error;
          }
        }

        if (attempt < this.maxRetries - 1) {
          const delay = Math.min(
            this.initialDelay * Math.pow(this.backoffMultiplier, attempt),
            30000
          );

          console.warn(
            `Deployment failed (attempt ${attempt + 1}/${this.maxRetries}), ` +
              `retrying in ${delay}ms: ${lastError.message}`
          );

          await this.sleep(delay);
        }
      }
    }

    console.error(`Deployment failed after ${this.maxRetries} attempts: ${lastError?.message}`);
    throw lastError;
  }

  /**
   * Sleep utility for retry delays
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Health check
   */
  async healthCheck(): Promise<{ status: string; vercelConfigured: boolean }> {
    return {
      status: 'ok',
      vercelConfigured: !!this.vercelToken,
    };
  }
}
